maxmasksz=namln;20;24       IF masksloopM        LD HL,CURMASKMASK0   CALL IYKEY        CP key_enter        JR Z,MASKe         cp 0x20        JR C,MASK0 ;прочие управляющие кнопки не нужны        LD (HL),A        INC HL        CALL PRSYM        ;LD A,(CURX)        push hl        ld de,CURMASK        scf        sbc hl,de        ld a,l        pop hl        CP maxmasksz-1        JR C,MASK0MASKe   LD (HL),0        JP LOOP;можно маску типа M*.EXECURMASK        DB "*"        DS maxmasksz-1        NOP CPMASK;HL=filename,DE=mask;both zeroend;"?"=1sym,"*">=0sym;символ после "*" не д.б внутри "*";Z=ok        LD HL,CURFILE        LD DE,CURMASKCPMASK0 LD A,(DE)        OR A        RET Z ;fff=fff*        INC DE        CP "?"        JR Z,CPMASKY        CP "*"        JR NZ,CPMASKN        LD A,(DE)        OR A        RET Z ;fff*CPMSKZ  LD A,(DE)        SUB (HL)        JR Z,CPMASK0        INC HL        CP (HL)        JR NZ,CPMSKZ       ;ff*d<>ff1        INC A        RET CPMASKN CP (HL)        RET NZCPMASKY INC HL        LD A,(HL)        OR A        JR NZ,CPMASK0        RET        ENDIF ;TWICERdTabs        LD B,2        CALL LDA18B       LD A,C        RRA       ;LD (Bit2),A ;UnpAudioBlock       JR C,dpPnKIL        LD HL,FRIY2       LD (HL),B        LD DE,FRIY2+1        LD BC,FRIY2ln-1        LDIR dpPnKIL       IF mmc      ;Bit2=$+1      ;LD A,0       RRA        JR NC,dPPn2b        IF 1==0        call RST16        DB #D,#a,"Audio blocks are not supported",0       LD A,251       LD (flgALL),A        CALL IYKEY        JP SPGO        ELSE         LD B,2        CALL LDA18B        LD A,C     ;LD HL,_7604 ;CurChannel     ;CP (HL) ;=0     ;JR NC,$+4     ;LD (HL),0       ADD A,1 ;A=1..4        LD H,A        ld L,A        JR $+5        ENDIF        ENDIF dPPn2b        LD HL,bdlensdPPtetr LD B,4        CALL LDA18B        LD (HL),C        INC L        JR NZ,dPPtetr        LD DE,19+1       INC L       inc H       ;LD HL,bdlens+19+1        LD BC,bd        ;jr $        CALL MKTREE        LD BC,298+48+28 ;tabsize        LD HL,FRIY2 ;UnpOldTabledPP0   PUSH HL       PUSH BC        LD HL,bd        CALL DEHUFF        LD A,L       POP BC       POP HL        SUB 16        JR NC,dPPbr16;<16 delta from prev codelen tab        ADD A,(HL)        AND #F        LD (HL),A        INC HL        DEC BC        JR dPPQdPPbr16        PUSH BC        JR NZ,dPPn16;16=prev len copies-3        LD B,2        CALL LDA18B       DEC HL       LD A,(HL)       INC HL       LD (dPPdupV),A        JR dPPfil3;18=zerolens-11dPPn3b        LD B,7        CALL LDA18B        LD A,11        JR dPPfildPPn16  DEC A        JR NZ,dPPn3b;17=zerolens-3        LD B,3        CALL LDA18BdPPfil3 LD A,3dPPfil  ADD A,C        POP BCdPPdupV=$+1dPPdup0 LD (HL),0        INC HL        DEC BC        DEC A        JR NZ,dPPdup0        LD (dPPdupV),AdPPQ    LD A,B       OR A       JP M,qqqq ;??ERROR?        OR C        JP NZ,dPP0qqqq        LD DE,299        LD HL,ldlens+299        LD BC,ld        CALL MKTREE       if retree       LD BC,ld       LD DE,reld       CALL RETREE       ENDIF       ifdef optbigBT       LD A,14       LD (obig),A      ENDIF         LD DE,49        LD HL,ddlens+49        LD BC,dd        CALL MKTREE      ifdef optbigBT       LD A,24       LD (obig),A      ENDIF         LD DE,29        LD HL,rdlens+29        LD BC,rd;создание дерева. нули - более короткие ветки;сначала создаются все ветки для;символов с bitlen=1, потом 2 и т.д. до 15;by Roman Petrov;FIXED:не строил пустое деревоMKTREE        PUSH BC        EXX         POP DE ;начало буфера        LD H,D        LD L,E        XOR A ;=0 признак выхода        PUSH AF        INC A ;=1        PUSH HL        PUSH AF        LD C,AMKTREE0 EXX      ;HL=кон.bitlens+1        LD B,D        LD C,E       ;ADD HL,BC;указ.на последний bitlen      ;OR A       SBC HL,BC;указ.на 1й bitlen        EXX MKTREE1 LD B,A        LD A,C        EXX        ;CPDR ;BC=число листьев+1       CPIR         LD A,B        OR C        EXX         LD A,B        JR NZ,MKTREEY;найден символ с таким bitlen        INC C ;не найден такой символ       JR NZ,MKTREE0       JR MTREEbugMKTREE_DEEPER        INC DE ;новое место        INC DE ;для        INC DE ;новых        INC DE ;узлов        LD (HL),E        INC HL        LD (HL),D ;указатель для "0"        LD H,D        LD L,E ;адрес для "код+0"        INC A  ;длина этого кода        PUSH HL ;заносим это        PUSH AF ;в стекMKTREEY CP C        JR NZ,MKTREE_DEEPER ;пока не углубимся до нужной длины       ;A=C        EXX         PUSH BC ;антиномер литерала+1       PUSH DE ;Q+1        EXX MTREEbug       LD (MKhl),HL       POP HL        POP BC       ;DEC BC ;номер литерала       ;LD (HL),C       ;INC HL       ;LD (HL),B ;формируем лист       SCF        SBC HL,BC      ifdef optbigBTobig   JR $+8       SLA L
       sla L       LD H,bigBT/256      ENDIF MKhl=$+1       LD (0),HL        LD C,A        POP AF        RET Z ;=0 признак выхода        POP HL        INC HL        INC HL ;следующий свободный узел           ;A=его глубина           ;DE=адрес места для новых узлов        JR MKTREE1       if retreeRETRp        LD A,218;JPC        LD (DE),A        INC DE       PUSH HL       PUSH DE       INC DE       inc DE       LD H,B       ld L,C       CALL RETREE ;для Ladr       POP HL       LD (HL),E ;адрес Radr       INC HL       LD (HL),D       POP HL        LD C,(HL)        INC HL        LD B,(HL)RETREE        LD H,B        ld L,C        EX DE,HL        LD (HL),135;AAA        INC HL        LD (HL),204;CZ        INC HL        LD (HL),bitik&0xff        INC HL        LD (HL),bitik/256        INC HL        EX DE,HL        LD C,(HL)        INC HL        LD B,(HL)        INC HL       IF (ld/256)&#40        BIT 6,B       ELSE        if (ld/256)&#80        BIT 7,B       else       IF (ld/256)&#20        BIT 5,B       ENDIF        endif       ENDIF         JR NZ,RETRp        EX DE,HL        LD (HL),1        INC HL        LD (HL),C        INC HL        LD (HL),B        INC HL        LD (HL),208;RNC        INC HL        EX DE,HL        LD C,(HL)        INC HL        LD B,(HL)        INC HL       IF (ld/256)&#40        BIT 6,B       ELSE        if (ld/256)&#80        BIT 7,B       else       IF (ld/256)&#20        BIT 5,B       ENDIF        endif       ENDIF         JR NZ,RETREE;для Radr        EX DE,HL        LD (HL),1        INC HL        LD (HL),C        INC HL        LD (HL),B        INC HL        LD (HL),201        INC HL        EX DE,HL        RET reldstored        LD B,8        EXA         CALL LDA18B ;B=0,C=rez        EXA         RET lnreldstored=$-reldstoredbitik        ;LD A,(IX)        ;INC LX        ;CALL Z,LDAsec
        rarrdbyte      ;SCF ;?        RLA         RET        ENDIF ;----------SCFEOF  SCF EOFlnLSW=$+1        LD HL,0        LD DE,(NXTPOS)       ;OR A        SBC HL,DE       PUSH HLlnHSW=$+1        LD HL,0        LD DE,(NXTPOS+2)        SBC HL,DE       POP DE        RET        IF unexpUNEXP       LD A,H       AND L,D,E       INC A       RET Z        call RST16        DB #D,#a,"Unexpected end"        DB 13,0       ;SCF        RET        ENDIF PREPAR        ;jr $        CALL FINDFIL        RET C        XOR A        LD L,A,H,L        LD (volPKSZ),HL        LD (volPKSZ+2),HL        LD (volUNSZ),HL        LD (volUNSZ+2),HL        LD (pieces),HL       ;LD (pieces+2),HL       LD (ERRORS),HL       CALL PRTHEE        CALL TSTOLD        JR NC,_nISN        call RST16        DB "not RAR",0        SCF         RET PRTHEE      ;XOR A       LD HL,THEEND       LD (DEPADR),HL       LD (stAD),HL       LD (stPG),A       JP OUTMEcu_nISN        LD HL,(SIZEA)        LD DE,-13        ADD HL,DE       LD DE,0       CALL SEEKpos ;TODO       ;RET C        call RST16       DB #D,#a,0        LD A,(SOLFLG)        AND A        JR Z,NOTsol        call RST16       DB "Solid ",0NOTsol        LD A,(VOLFLG)        CP 2       JR NZ,NOTvol        call RST16       DB "volume",0        JR NOTarcNOTvol  call RST16       DB "archive",0NOTarc  PRRARNAME;out: CY=0        call RST16        db " "       ;if 1==0       DB 1curfilenameaddr=$       DW 0;TWORK       ;endif              DB #D,#a,0        OR A        RET FINDFIL        ld de,(curfilenameaddr)
        call openstream_file
        or a
        jp nz,openerror
        ld a,(filehandle)
        ld b,a
        OS_GETFILESIZE ;dehl=filesize
       LD (lnLSW),hl       ld a,e       LD (lnHSW),A       ld a,d       LD (lnHSW+1),A               LD HL,0       LD D,h        LD E,LSEEKst;set position in archive file to dehl        ld (CURPOS),hl        ld (CURPOS+2),de        ;ld de,0
        ;ld hl,0 ;dehl=shift
        ld a,(filehandle)
        ld b,a
        OS_SEEKHANDLE       ;LD A,L       ;LD ly,a;LX,A       LD IY,DISKBUF+DISKBUFsz-1 ;TODO SEEK только если куска нет в буфере        or a
        retSEEKpos;skip dehl bytes        ld a,h        or l        or d        or e        ret zSEEKpos0        rarrdbyte        dec hl        ld a,h        or l        jr nz,SEEKpos0        ld a,d        or e        dec de        jr nz,SEEKpos0        ret        LOADBLK        ;if 1==0        ld hl,(CURPOS)        add hl,bc        ld (CURPOS),hl        ld hl,(CURPOS+2)        jr nc,$+3        inc hl        ld (CURPOS+2),hl        ;endif        ;load bc bytes to de        PUSH BC        push DE        LOADBL0
        ;LD A,(IX)        ;INC LX        ;CALL Z,LDAsec
        rarrdbyte        LD (DE),A        INC DE        DEC BC        LD A,B        OR C        JR NZ,LOADBL0        POP HL        pop BC      ;OR A        RET        IF crcUPCRC        PUSH BC       IF tcrc==0        LD C,(iy);(IX)        LD B,8crclp   LD A,E        XOR C        SRL C
        srl H        RR L
        rr D
        rr E        RRA         JR NC,noxor        LD A,H        XOR #ED        LD H,A        LD A,L        XOR #B8        LD L,A        LD A,D        XOR #83        LD D,A        LD A,E        XOR #20        LD E,Anoxor   DJNZ crclp       ELSE         LD B,H
        ld C,L        LD A,E        XOR (iy);(IX)        LD L,A        LD H,TCRC/256        LD A,(HL)        XOR D        LD E,A        INC H        LD A,(HL)        XOR C        LD D,A        INC H        LD A,(HL)        XOR B        INC H        LD H,(HL)
        ld L,A       ENDIF         POP BC        INC iy;IX        DEC BC        LD A,B        OR C        JR NZ,UPCRCUPPASS  RET        ENDIF DEHUFF        EXA DEHUFF0 ADD A,A        JR Z,NEWDEHF        JR NC,$+4 ;нольDEHFC   INC L  ;единица        INC L;HLDEHFNC  LD C,(HL)        INC L        LD H,(HL)        LD L,C       IF (rd/256)&#40        BIT 6,H       ELSE        if (rd/256)&#80        BIT 7,H       else       if (rd/256)&#20        BIT 5,H       endif       endif       ENDIF         JP NZ,DEHUFF0        EXA         RET NEWDEHF;?/frame        ;LD A,(IX)        ;INC LX        ;CALL Z,LDAsec
        rarrdbyte       SCF        RLA         JR C,DEHFC        JP DEHFNCLDAldb0;3t/frame        ;LD A,(IX)        ;INC LX        ;CALL Z,LDAsec
        rarrdbyte       SCF        RLA         JP LDA0CLDAldb1;4t/frame        ;LD A,(IX)        ;INC LX        ;CALL Z,LDAsec
        rarrdbyte       SCF        RLA         JP LDA1CLDAldb2;?/frame        ;LD A,(IX)        ;INC LX        ;CALL Z,LDAsec
        rarrdbyte       SCF        RLA         JP LDA2C;4 timesLDA        CP 9        JR NC,lDA915;3 timesLDA18   LD B,ALDA18B      LD C,0        EXA LDA0    ADD A,A        JR Z,LDAldb0LDA0C   RL C        DJNZ LDA0        EXA         RET lDA915  SUB 8LDAB        LD B,A      LD C,0        EXA LDA1    ADD A,A        JR Z,LDAldb1LDA1C   RL C        DJNZ LDA1        LD B,C        LD C,1LDA2    ADD A,A        JR Z,LDAldb2LDA2C   RL C        JP NC,LDA2        EXA OLDdepk RET restore;чтение сектора destination file: restoreLAST (??? TODO) в stBUF        PUSH DE;resec=$+1;       LD HL,0;        PUSH HLrestoreLAST=$+1        LD DE,0;а был ли глюк? ничего не понимаю        LD (restoreLAST),HL       EX DE,HL        XOR A        SBC HL,DE       JR Z,restQ ;SAME SEC       ;IF border       ;LD A,2       ;OUT (-2),A       ;ENDIF         ;LD HL,stBUF        PUSH BC        push ix        push iy        ;LD BC,#105        ;CALL DOD        ld de,stBUF        ld hl,0x100        ld a,(savefilehandle)        ld b,a        OS_READHANDLE        pop iy        pop ix
        POP BC       ;IF border       ;XOR A       ;OUT (-2),A       ;ENDIF       IF frmcnt      LD HL,(swaps)      INC HL      LD (swaps),HL      ENDIF restQ       if 1==0        POP HL        LD DE,stBUF        INC L        BIT 4,L        JR Z,$+4        INC H        LD L,E       LD A,H       SUB 160       JR C,$+3       LD H,A        LD (resec),HL       EX DE,HL ;??? TODO       endif        POP DE        RET GETPOSp        XOR A       LD E,L,L,H        LD H,A,D,A        ADD HL,HL,HL,HL,HL,HL        ADD HL,HL,HL,DE        RET ;------------------

PRHLDE        CALL PRNUM        EX DE,HL        CALL PRNUM        EX DE,HL        RET PDECPP        EXA         PUSH HL        EXX         POP HL        LD A,H        OR L        EXX         OR E,D        EX DE,HL        LD DE,DECBUF-1        JR NZ,pRDN0        LD A,"0"        LD (DE),A        DEC DEpRDN0   EXA         PUSH AFprd0        EXA         LD BC,#210A        XOR AprdDIV  RLA         SUB C        JR NC,$+3        ADD A,C        CCF         ADC HL,HL        EXX         ADC HL,HL        EXX         DJNZ prdDIV        LD C,A        OR H,L        EXX         OR H,L        EXX         LD A,"0"        JR NZ,$+4        LD A,32DECSPACE=$-1        ADD A,C        LD (DE),A        DEC DE        EXA         DEC A        JR NZ,prd0        POP AF        LD E,A       XOR A       LD D,A        LD HL,DECBUF        SBC HL,DE        RET PRDEC        EX DE,HL        LD HL,0PRDECHLDE       CALL PDECPP;1,addr=TOKENPRRST   LD A,(HL)        INC HL        DEC A        JR NZ,rstNat        LD E,(HL)        INC HL        LD D,(HL)        INC HL        PUSH HL        EX DE,HL        CALL PRRST        POP HL        JR PRRSTrstNat  INC A        RET Z        CALL PRSYM       JR PRRSTRST16        pop hl        push af        call PRRST        pop af        jp (hl)        if 1==0PRCUR
        ld e,CURSORCOLOR
        jr RECUR_go
RECUR
        ld e,COLOR
RECUR_go
;        ld hl,0
;CURX=$-2;CURY=$-1
PRCURHL
        push iy
        push de
        ex de,hl
        ;OS_SETXY
        pop de
        OS_PRATTR
        pop iy
        ret        endifIYKEY        ;XOR A        ;LD (SCROLLINES),A       ;SCF ;флаг был нужен только в одном местеflgALL  EI ;/retSUREKEY PUSH IX,HL,DE,BC       PUSH IY        ;CALL PRCURiykey_nokey
        call yieldgetkeyloop ;YIELDGETKEYLOOP        or a        jr z,iykey_nokey
        ;push af        ;CALL RECUR        ;pop af       POP IY        POP BC,DE,HL,IX        RET PRNUM           LD A,H        CALL PRHEX        LD A,LPRHEX           PUSH HL        LD HL,HEXBUF        LD (HL),A        CALL HEXDIG        call HEXDIG        POP HL        RET HEXDIG          XOR A        RLD         CP 10        CCF         ADC A,"0"        DAA PRSYM           push AF        push BC        push DE        push HL        PUSH IX        push iy
        PRCHAR_;CALL PR64        pop iy
        pop IX        pop HL        pop DE        pop BC        POP AF        RET 
;HL'HL/DE'DE*100%PERCENT        EXX          LD A,H         OR L        EXX         JR NZ,perN0 ;>ffff        LD A,H,H,L        EXX          LD L,A        EXX         LD A,D,D,E        EXX          LD E,A        EXX perN0  LD BC,#2164       XOR AperDIV RLA        SUB C       JR NC,$+3       ADD A,C       CCF        ADC HL,HL       EXX         ADC HL,HL       EXX        DJNZ perDIV        EX DE,HL       LD A,D       OR E        EXX         EX DE,HL       OR D,E        EXX        RET Z        XOR AperSUB  SBC HL,DE        EXX          SBC HL,DE        EXX         INC A        JR NC,perSUB        DEC A        CP 101        RET C        LD A,100        RET TSTOLD        XOR A       LD (VOLFLG),A       LD (SOLFLG),A       LD (TSTARES),A        LD DE,ARCBEG        LD BC,7        CALL LOADBLK ;load bc bytes to de        RET C       ;LD HL,ARCBEG        LD A,"R"        CPI         JR NZ,TSTRARH        LD A,#45        CPI         JR NZ,TSTRARH        LD A,#7E        CPI         JR NZ,TSTRARH        LD A,#5E        CP (HL)        JR NZ,TSTRARH        call RST16        DB "old RAR"       IF opt==0        DB " format detected"       ENDIF         DB #D,#a,0        LD A,1        LD (TSTARES),A        LD HL,0       LD D,H       ld E,L       CALL SEEKst       ;RET C        SCF         RET TSTRARH        LD HL,ARCBEG        LD A,"R"       SCF         CPI        RET NZ        LD A,"a"        CPI        RET NZ        LD A,"r"        CPI        RET NZ        LD A,"!"        CPI        RET NZ        LD A,#1A        CPI        RET NZ        LD A,7        SUB (HL)        INC HL        OR (HL)       SCF        RET NZ        LD A,2        LD (TSTARES),A        LD DE,CRCA        LD BC,13        CALL upcrc;archead        RET C        LD A,(FLAGA)        AND 1       INC A        LD (VOLFLG),A       IF crc        LD HL,-1        LD DE,(CRCArea)        AND A        SBC HL,DE        LD DE,(CRCA)        SBC HL,DE        JR Z,_9436        call RST16        DB "Archive header broken",#D,#a,0        SCF         RET _9436       ENDIF         LD A,(FLAGA)        AND 8       RRCA        RRCA        RRCA         LD (SOLFLG),A       ;AND A        RET ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TWICE;CURPOS used only hereSCAN;scan archive for block type=hl        LD (EXPTYP),HL                if 1==0SCAN0       LD DE,CRCF       LD BC,7       call upcrc ;read 7 bytes       RET C       ;LD (CRCLO),HL        LD DE,(SIZEF) ;from file header ;head size                LD HL,7       ;OR A        SBC HL,DE       CCF         RET C ;<=7       push de       ld de,CRCF+7       ld bc,32-7       call addcrc ;read 32-7 bytes       pop de       ret c         ld hl,0      LD A,(FLAGF+1)        RLA         JR NC,nADD;Поле ADD_SIZE присутствует, только если (HEAD_FLAGS & 0x8000) != 0         LD HL,(ADDSZF)        ADD HL,DE        LD de,(ADDSZF+2)        jr nc,$+3        inc denADD;dehl=add to curpos before TSTPP        push hl        LD HL,EXPTYP        LD A,(TYPEF)        CP (HL)        pop hl        JR Z,SCANREADSCANSKIP;dehl=add to curpos before TSTPP        ld bc,32        or a        sbc hl,bc        jr nc,$+3        dec de       CALL SEEKpos ;skip dehl bytes        jr SCAN0        else        SCAN0        if 1==0        LD HL,(DESCRIP+14)        CALL GETPOSp        PUSH HL        LD HL,(TRSEC)        CALL GETPOSp        POP DE       ;XOR A        SBC HL,DE;TODO hly=current position in file        LD E,ly;LX        LD D,L,L,H        LD H,A ;DEHL наоборот        LD (CURPOS),DE        LD (CURPOS+2),HL        endif       LD DE,CRCF       LD BC,7       ;jr $       call upcrc ;read 7 bytes       RET C       ;LD (CRCLO),HL        LD DE,(SIZEF)        LD HL,7       ;OR A        SBC HL,DE       CCF         RET C ;<=7       push de       ld de,CRCF+7       ld bc,32-7       call addcrc ;read 32-7 bytes ;TODO fix CRC       pop de       ret c ;было: CURPOS=позиция начала заголовка;теперь: CURPOS=позиция начала заголовка + 32        LD HL,(CURPOS)       ;LD DE,(SIZEF)        ADD HL,DE       EX DE,HL        LD HL,(CURPOS+2)        JR NC,$+3        INC HL      ;JR Z,nADD ;BLOCK #7B        LD A,(FLAGF+1)        RLA         JR NC,nADD       PUSH HL        LD HL,(ADDSZF)        ADD HL,DE       EX DE,HL       POP BC        LD HL,(ADDSZF+2)        ADC HL,BCnADD        ex de,hl         ld bc,32         or a         sbc hl,bc         jr nc,$+3         dec de        LD (NXTPOS),hl        LD (NXTPOS+2),de      CALL EOF      RET C_nUNE        LD HL,EXPTYP        LD A,(TYPEF)        CP (HL)        JR Z,SCANREADSCANSKIP        LD HL,(NXTPOS)       LD DE,(NXTPOS+2)       CALL SEEKst        JP SCAN0      endifSCANREAD;выход из scan        LD HL,(NAMSIZE)        LD DE,namln-1        AND A        SBC HL,DE        ADD HL,DE        JR C,$+3        EX DE,HL       ;LD (NAMSIZE),HL        LD DE,CURFILE        LD B,H        ld C,L ;длина имени файла        CALL LOADBLK ;load bc bytes to de        LD (DE),A;0      IF crc==0       OR A       RET       ELSE        ;LD A,(TSTARES)       ;CP 2 ;?       ;JR NZ,nBROKEN       PUSH HL        LD HL,(CRCArea+2)        LD DE,(CRCArea)        ;LD BC,(NAMSIZE)       EX (SP),iy;IX        CALL UPCRC ;считаем CRC iy=CURFILE       POP iy;IX        LD HL,(CRCF)        SCF         ADC HL,DE       CCF        RET Z ;NC        call RST16        DB #D,#a,1        DW CURFILE        DB " bad header",#D,#a,0        SCF         RET       ENDIF             ;CY=errorupcrc;de=addr, bc=size      ;LD A,(TSTARES)      ;DEC A      ;SCF ;oldRAR      ;RET Z      IF crc==0addcrc       JP LOADBLK ;load bc bytes to de      ELSE         CALL LOADBLK ;load bc bytes to de        RET C        INC HL        inc HL       PUSH HL        DEC C        dec C ;2 байта в начале блока не учитываем в CRC        LD HL,-1        ld D,H        ld E,Laddcrcq       EX (SP),iy;IX        CALL UPCRC ;считаем CRC iy=CRCF/CRCA       POP iy;IX        LD (CRCArea),DE        LD (CRCArea+2),HL       ;AND A        RET addcrc        CALL LOADBLK ;load bc bytes to de        RET C       push hl        ld de,(CRCArea)        ld hl,(CRCArea+2)        jr addcrcq      ENDIF EXTRACT       CALL PREPAR       RET CEXTR0        LD HL,#8074        CALL SCAN       ;LD (SCANres),HL       ;LD A,H       ;OR L       JP C,SHOWQUI       IF masks       CALL CPMASK       JR NZ,EXnMSK       ENDIF         LD A,(TYPEF)        CP #74        JR Z,EXTR74 ;fileEXnMSK        LD HL,(NXTPOS)       LD DE,(NXTPOS+2)       CALL SEEKst        JP EXTRq       ;jp _DEPKOK ;TODO как проверить?EXTR74        LD A,(FLAGF)       RRA        JR NC,EXnBAD       ;LD A,(SOLFLG)       ;OR A       ;JR Z,EXnBAD        call RST16 DB "bad RAR type",0        SCF         RET EXnBAD        ;if 1==0        LD HL,(NXTPOS)        LD DE,(ADDSZF)        SBC HL,DE       EX DE,HL       LD HL,(NXTPOS+2)       LD BC,(ADDSZF+2)       SBC HL,BC       EX DE,HL       CALL SEEKst        ;endif ;TODO               LD HL,CURFILE        LD DE,OUTNAM        LD BC,namln        LDIR        LD A,1       LD (known),A        LD A,(UNPVER)        CP 13        JR C,badver        DEC A        CP 20        JR C,goodverbadver  call RST16        DB #D,#a,"Bad method ",1        DW CURFILE        DB 0       XOR A       LD (known),Agoodver;LD A,(ATTR)       ;BIT 3,A       ;JP NZ,EXTRq       ;AND 16       ;JP NZ,EXTRq        call RST16        DB #D,#a,1        DW OUTNAM        DB "(Y,N,All)"        DB 0        LD HL,(UNPSIZE+2)        LD (uNPremn+2),HL        LD HL,(UNPSIZE)        LD (uNPremn),HL        CALL IYKEY
       cp key_esc        JP z,SHOWQUI ;NC        AND #DF       LD (doSAVEk),A        CP "N"        JR NZ,KnN        LD A,(FLAGA)        AND 8        JP Z,_DEPKOK ;not 'all'       JR EXTRnOKKnN     CP "A"        JR NZ,KnALL       LD A,201       LD (flgALL),AKnALL        call SAVECREATE ;OUTNAM        LD A,(METHOD)        CP #30 ;storing       JR NZ,NSTORE        LD A,16        LD (FLAGF),A       LD HL,dd       LD DE,dd+1       LD BC,256       LD (HL),8       LDIR        LD C,297&0xff       LD (HL),B       LDIR        LD DE,299       INC HL,HL       LD BC,ld       CALL MKTREE       LD HL,(DEPADR)       LD (stAD),HL       LD A,(curPG)       LD (stPG),ANSTORE        CALL DEPK        call SAVECLOSE        ;ld hl,0        ;ld (ADDSZF),hl        ;ld (ADDSZF+2),hl_DEPKOK        LD HL,(NXTPOS)       LD DE,(NXTPOS+2)       CALL SEEKst       ; LD HL,(ADDSZF)       ; LD de,(ADDSZF+2)       ;CALL SEEKpos ;skip dehl bytesEXTROK        call RST16        DB " Ok",0EXTRnOK        LD A,(known)        OR A        LD HL,(NXTPOS)        LD DE,(NXTPOS+2)       CALL Z,SEEKstEXTRq       CALL SCFEOF        JP NC,EXTR0       IF unexp       CALL UNEXP       ENDIF SHOWQUI        LD HL,(ERRORS)        LD A,H        OR L        JR NZ,EXTRnAOK        call RST16        DB #D,#a,"All OK",0        RET EXTRnAOK        call RST16        DB #D,#a,"Total errors: ",0        LD HL,(ERRORS)        LD A,#10        JP PRDECCONTENTS       CALL PREPAR       RET C        call RST16        DB "    Size Packed Ratio Date Met Ver"        db #d,#a        db 0CONTENTS0;_9549       ;CALL 8020       ;RET NC        LD HL,#0074        CALL SCAN        JP C,VOLpars       IF masks       CALL CPMASK       JP NZ,CONTskip       ENDIF         LD A,(FLAGF)        AND 4       LD A,"*" ;encrypted       JR NZ,$+4       LD A,32        CALL PRSYM       ; call RST16       ;DB 1       ;DW CURFILE       ;DB 0        ;call RST16        ;DB #D,#a,0        LD HL,(UNPSIZE+2)        LD DE,(UNPSIZE)        LD A,7;unpacked size        CALL PRDECHLDE        LD HL,(ADDSZF+2)        LD DE,(ADDSZF)        LD A,7;packed size        CALL PRDECHLDE        call RST16       DB " ",0        LD A,(FLAGF)        AND 3        CP 3        JR NZ,_npvnx        call RST16;from prev to next vol       DB " <->",0        JR FILETIM_npvnx CP 1        JR NZ,_npv        call RST16;from prev       DB " <--",0        JR FILETIM_npv   CP 2        JR NZ,_nnx        call RST16;to next vol       DB " -->",0        JR FILETIM_nnx    EXX         LD HL,(UNPSIZE+2)        LD DE,(ADDSZF+2)        EXX         LD HL,(UNPSIZE)        LD DE,(ADDSZF)        CALL PERCENT        LD H,0,L,A        LD A,3        CALL PRDEC;ratio%        call RST16        DB "% ",0FILETIM LD A,"0"        LD (DECSPACE),A        LD HL,(FTIME+2)        LD DE,(FTIME)        LD A,L        AND 31        ADD HL,HL        add HL,HL        add HL,HL        LD L,A        ld A,H        AND #F        LD H,A        ld A,E        SRL D        RRA         SRL D        RRA         SRL D        RRA         RRA         RRA         AND 63        LD E,A       LD A,L        PUSH HL        LD H,0        LD A,2        CALL PRDEC        POP HL        LD L,H        ld H,0        LD A,2        CALL PRDEC        LD A,(FTIME+3)        SRL A        LD L,A        ld H,0        LD DE,#7BC        ADD HL,DE        LD DE,100        SBC HL,DE        JR NC,$-2        ADD HL,DE ;HL=остаток mod 100        LD A,2        CALL PRDEC;напечатать 2 цифры        LD A,32        LD (DECSPACE),A        LD A,(METHOD)        LD (_meth),A        call RST16        DB " ",0,0_meth=$-2        LD A,(FLAGF)        AND #E0        CP #81        JR NC,directory        RLCA         RLCA         RLCA        AND 7        ADD A,"a"        CALL PRSYMdirectory call RST16        DB " ",0        LD HL,#2F0A        LD A,(UNPVER)        INC H        SUB L        JR NC,$-2        ADD A,"0"+10        LD (_96fd+2),A        LD A,H        LD (_96fd),A        call RST16_96fd  DB "0.0",0        call RST16        db " "       DB 1       DW CURFILE        DB #D,#a       DB 0        LD A,(FLAGF)       RRA        JR C,Nfrprev        LD HL,(volUNSZ)        LD DE,(UNPSIZE)        ADD HL,DE        LD (volUNSZ),HL        LD HL,(volUNSZ+2)        LD DE,(UNPSIZE+2)        ADC HL,DE        LD (volUNSZ+2),HL        LD HL,(pieces)       INC HL        LD (pieces),HLNfrprev LD HL,(volPKSZ)        LD DE,(ADDSZF)        ADD HL,DE        LD (volPKSZ),HL        LD HL,(volPKSZ+2)        LD DE,(ADDSZF+2)        ADC HL,DE        LD (volPKSZ+2),HLCONTskip        LD HL,(NXTPOS)       LD DE,(NXTPOS+2)       CALL SEEKst              ; LD HL,(ADDSZF)       ; LD de,(ADDSZF+2)       ;CALL SEEKpos ;skip dehl bytes               CALL SCFEOF        JP NC,CONTENTS0;_9549 ;next file;какая-то ошибка? внезапный конец архива?       IF unexp       CALL UNEXP       ENDIF VOLpars        call RST16        DB #D,#a,0       ;LD HL,(pieces+2)       LD HL,(pieces)       LD A,5       CALL PRDEC        LD HL,(volUNSZ+2)        LD DE,(volUNSZ)        LD A,9;17        CALL PRDECHLDE        LD HL,(volPKSZ+2)        LD DE,(volPKSZ)        LD A,9        CALL PRDECHLDE        call RST16        DB " ",0        EXX         LD HL,(volUNSZ+2)        LD DE,(volPKSZ+2)        EXX         LD HL,(volUNSZ)        LD DE,(volPKSZ)        CALL PERCENT        LD H,0        ld L,A        LD A,3        CALL PRDEC        call RST16        DB "%",#D,#a,0        AND A        RET readerror
        call SAVECLOSE
        ;jp SPGO
SPGO        call closestream_file
SPGO_sp=$+1        LD SP,0;STACK;#6000CLSGO        ;CALL CLS        call RST16        ;DB "UNRAR",v1,".",v2,v3;        DB "A>A";src=$-3;dst=$-1        DB #D,#a,"Workfile"        ;db " ";TWORK  DB "masm_src"        db 0        call PRRARNAME        call RST16        DB "Mask "       db 1       dw CURMASK        db 0LOOP       LD A,251       LD (flgALL),A        call RST16        DB #D,#a,">",0        CALL IYKEY        CP key_enter        JR Z,CLSGO                if 1==0        LD HL,TDRIVS        LD BC,8        CPIR         JR Z,loopDRV        endif                AND #DF        CALL PRSYM        call RST16        DB #D,#a,0        LD (COMSYM),A        CP "E"        JR Z,loopE        CP "V"        JR Z,loopV        CP "Q"        jp Z,quit       IF masks        CP "M"        JP Z,loopM       ENDIF 
;start hereloopW        if 1==0;TODO        CALL PRCAT        JR C,CLSGO        LD DE,TWORK        LD BC,8        LDIR         endif        JR CLSGOloopE   CALL EXTRACT        call closestream_file        JR LOOPloopV   CALL CONTENTS        call closestream_file        JR LOOP                if 1==0loopDRV LD A,7        SUB C        LD HL,src        CP 4        JR C,lDRVsrc        LD HL,dst        SUB 4lDRVsrc ADD A,"A"        LD (HL),A        JR CLSGO        endif        ;konec
GO        ld (SPGO_sp),sp       IFN tcrc         xor a        LD L,AMKTCRC0 EXX         LD HL,0        ld D,H        ld E,A        LD B,8MKTCRC1 SRL H        RR L        rr D        rr E        JR NC,MKTCRCe        EXA         LD A,E        XOR #20        LD E,A        ld A,D        XOR #83        LD D,A        ld A,L        XOR #B8        LD L,A        ld A,H        XOR #ED        LD H,A        EXA MKTCRCe DJNZ MKTCRC1        PUSH HL        PUSH DE        EXX        LD H,TCRC/256        POP DE        LD (HL),E        INC H        LD (HL),D        INC H        POP DE        LD (HL),E        INC H        LD (HL),D        INC L        INC A        JR NZ,MKTCRC0       ENDIF         CALL PRAUTH;ONCE        JP loopW

;TODOp48        EXX         LD H,D
        ld L,E        LD BC,(disp)        LD A,(curPG)        SBC HL,BC        SET 7,Hp48sz=$-p48
PRAUTH        call RST16        ;DB "UNRAR",v1,".",v2,v3,"lite",#D,#a        db "v = view, e = extract, m = set mask, q = quit"        ;DB "4=48",#D,#a        ;DB "other keys=1M"        db 0        if 1==0        CALL IYKEY        OR 32        CP "4"        JR NZ,Npatch48       LD HL,GPmem+GPmemsz-p48sz       LD (GPaddrpatch),HL       EX DE,HL        LD HL,p48        LD BC,p48sz        LDIR        LD A,201       LD (OUTME),A       ;LD (hobetasym),A ;no hobeta
        xor a
       JR patch2       endifNpatch48        LD C,64;64-2;+1 ;число страниц памяти?        LD A,C        LD (_p1+1),A ;изначально там INITIALMEMPAGES;6patch2        LD (_4+1),A        LD (_3+1),A        LD (_5+1),A        ;LD (_6+1),A       LD (L_pg+1),A        NEG         LD L,A
        ld H,-1        INC HL
        dup 6
        add hl,hl
        edup        LD DE,THEEND/256-256        ADD HL,DE        LD (_2+1),HL        RET         ;DISPLAY /T,konec,"(",CODETOP,")"