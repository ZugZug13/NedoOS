        DEVICE ZXSPECTRUM128	include "settings.asm";music=doublescrNTEXPGS=0;curpg=0x5b5cpgtmp=#04pgmusic=#06texturesinpg=12spritesinpg=8;4;tcos=#5B00imer=#7F7FINTSTACK=imerimstackbegin=imer&0xff00distbuf=#7C00 ;#300 ;ID,texx,dist ;при ширине 24 chr$ в конце каждого 64 пустых байта, (а с 0x7f00 96 пустых (дальше стек и обработчик) заняты куском рисовалки hud)LOWHUD=1	page 0        ORG #6000;,0begin	jp init       IF doublescrSETPGmusic_silent        ld a,pgmusic        jr SETPG_silentSETPG        LD (curpg),ASETPG_silentcurscr=$+1        OR 0        LD BC,#7FFD        OUT (C),A        RET       ENDIF	include "my_int.asm"        INCLUDE "WCTRL.ASM"        display "wctrl end=",$        include "beeper.asm"        ;include "beeper_sfxdata.asm"	include "anims.asm"	include "savestate.asm"drawhudhealth       if LOWHUD       dec d       endif        if doublescr        push de        call drawhudhealth_1scr        pop de        set 7,ddrawhudhealth_1scr        endif        ex de,hl        inc h        ;ld hl,0x50e0+25        ld a,(health)        srl a        ld e,adrawhudhealthline0        push hl        ld (hl),0x3f        ld b,6        inc l        ld (hl),0xff        djnz $-3        pop hl        inc h        bit 0,h        jr z,drawhudhealthline0        ld (hl),0x20        inc h        ld a,-4        call drawhudhealthcolumncount        set 5,c        call drawhudhealthcolumn        call drawhudhealthcolumncountdraw2        call drawhudhealthcolumncountdraw2drawhudhealthcolumncountdraw2        call drawhudhealthcolumncountdrawdrawhudhealthcolumncountdraw        call drawhudhealthcolumncountdrawhudhealthcolumn;de=scraddr;c=1100000 и т.п.        ld (hl),c        inc h        ld (hl),c        inc h        ld (hl),c        dec h        dec h        inc l        ret       if 0demobegin       IF demoplay        INCBIN "demorec*"       ELSE        DB %00111111 ;all keys released       ENDIF       endif        include "hud.ast"        display $," before align"	align 256tlogd2sca       IF scale64       IF scale64 == 3        INCBIN "logd2sc3"       ELSE        INCBIN "logd2sc2"       ENDIF       ELSE        INCBIN "logd2sc_"       ENDIFtsqr2        INCBIN "sqr2int"tlogd        INCBIN "logd" ;первые 128 байт (сейчас 64 при antizalom) не используются - займём часть:        org $-256        include "beeper_sfxdata.asm"        org ($&0xff00)+256tcorrlogd        INCBIN "corlogd_" ;последние 64 байта свободны при ширине 24 chr$ - TODO        ORG $-256       DUP scrwid*8;256        DB {$+(scrtopx*8)}&0xff       EDUPdrawhud;вызывается из ZXLOOP       IF doublescr        LD A,#17        CALL SETPG       ENDIF        ld hl,sprweapon1        ld de,0x50e0-1+(256*LOWHUD)        call x4_ince_drawsprchr2        ;call x2_ince_drawsprchr2        ;call x2_ince_drawsprchr2        inc e        call drawsprchr ;sprbullets        ld a,(bullets)        call draw99        inc e        call drawsprchr ;sprgrenades        ld a,(grenades)        call draw9        inc e        ld a,(leveltime+2)        call draw99        ld a,(leveltime+1)        call draw99        ld bc,0x52e0+21        call drawhuddot        ld bc,0x55e0+21        call drawhuddot        inc e        call drawsprchr ;sprhealth        jp drawhudhealth       if $&0xff        ds (-$)&0xff,0       endif       IF lores        ORG $-256_=$       DUP 128        DB {_}&0xff_=_+2       EDUP        DS 128       ENDIF;tcos        ;DS 256tlogcos        INCBIN "pluslcos"tda        INCBIN "da"        ORG $-256       DUP 256        DB 0xff&({$}+128)       EDUP        ORG $-256       DUP 256        DB 0xff&({$+(scrtopx*8)})       EDUP       IF lores        ORG $-256_=$       DUP 128        DB {_}&0xff_=_+2       EDUP        DS 128       ENDIFtctg        INCBIN "plusctg"tsin        INCBIN "sin"       if 1;		z=0:255; sprintf('%d,',fix(atan(2.^(z/32))*128/pi))		;;;;;;;; atan(2^(x/32))*128/pi ;;;;;;;;atan_tab:		db 020h,020h,020h,021h,021h,022h,022h,023h,023h,023h,024h,024h,025h,025h,026h,026h		db 026h,027h,027h,028h,028h,028h,029h,029h,02Ah,02Ah,02Ah,02Bh,02Bh,02Ch,02Ch,02Ch		db 02Dh,02Dh,02Dh,02Eh,02Eh,02Eh,02Fh,02Fh,02Fh,030h,030h,030h,031h,031h,031h,031h		db 032h,032h,032h,032h,033h,033h,033h,033h,034h,034h,034h,034h,035h,035h,035h,035h		db 036h,036h,036h,036h,036h,037h,037h,037h,037h,037h,037h,038h,038h,038h,038h,038h		db 038h,039h,039h,039h,039h,039h,039h,039h,039h,03Ah,03Ah,03Ah,03Ah,03Ah,03Ah,03Ah		db 03Ah,03Bh,03Bh,03Bh,03Bh,03Bh,03Bh,03Bh,03Bh,03Bh,03Bh,03Bh,03Ch,03Ch,03Ch,03Ch		db 03Ch,03Ch,03Ch,03Ch,03Ch,03Ch,03Ch,03Ch,03Ch,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh		db 03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Dh,03Eh,03Eh,03Eh,03Eh		db 03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh		db 03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Eh,03Fh,03Fh,03Fh,03Fh		db 03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh		db 03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh		db 03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh		db 03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh		db 03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh ;		x=0:255;x(1)=1; sprintf('%d,',fix(32*log2(x)))		;;;;;;;; log2(x)*32 ;;;;;;;;log2_tab:		db 000h,000h,020h,032h,040h,04Ah,052h,059h,060h,065h,06Ah,06Eh,072h,076h,079h,07Dh		db 080h,082h,085h,087h,08Ah,08Ch,08Eh,090h,092h,094h,096h,098h,099h,09Bh,09Dh,09Eh		db 0A0h,0A1h,0A2h,0A4h,0A5h,0A6h,0A7h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh,0B0h,0B1h		db 0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0B9h,0BAh,0BBh,0BCh,0BDh,0BDh,0BEh,0BFh		db 0C0h,0C0h,0C1h,0C2h,0C2h,0C3h,0C4h,0C4h,0C5h,0C6h,0C6h,0C7h,0C7h,0C8h,0C9h,0C9h		db 0CAh,0CAh,0CBh,0CCh,0CCh,0CDh,0CDh,0CEh,0CEh,0CFh,0CFh,0D0h,0D0h,0D1h,0D1h,0D2h		db 0D2h,0D3h,0D3h,0D4h,0D4h,0D5h,0D5h,0D5h,0D6h,0D6h,0D7h,0D7h,0D8h,0D8h,0D9h,0D9h		db 0D9h,0DAh,0DAh,0DBh,0DBh,0DBh,0DCh,0DCh,0DDh,0DDh,0DDh,0DEh,0DEh,0DEh,0DFh,0DFh		db 0DFh,0E0h,0E0h,0E1h,0E1h,0E1h,0E2h,0E2h,0E2h,0E3h,0E3h,0E3h,0E4h,0E4h,0E4h,0E5h		db 0E5h,0E5h,0E6h,0E6h,0E6h,0E7h,0E7h,0E7h,0E7h,0E8h,0E8h,0E8h,0E9h,0E9h,0E9h,0EAh		db 0EAh,0EAh,0EAh,0EBh,0EBh,0EBh,0ECh,0ECh,0ECh,0ECh,0EDh,0EDh,0EDh,0EDh,0EEh,0EEh		db 0EEh,0EEh,0EFh,0EFh,0EFh,0EFh,0F0h,0F0h,0F0h,0F1h,0F1h,0F1h,0F1h,0F1h,0F2h,0F2h		db 0F2h,0F2h,0F3h,0F3h,0F3h,0F3h,0F4h,0F4h,0F4h,0F4h,0F5h,0F5h,0F5h,0F5h,0F5h,0F6h		db 0F6h,0F6h,0F6h,0F7h,0F7h,0F7h,0F7h,0F7h,0F8h,0F8h,0F8h,0F8h,0F9h,0F9h,0F9h,0F9h		db 0F9h,0FAh,0FAh,0FAh,0FAh,0FAh,0FBh,0FBh,0FBh,0FBh,0FBh,0FCh,0FCh,0FCh,0FCh,0FCh		db 0FDh,0FDh,0FDh,0FDh,0FDh,0FDh,0FEh,0FEh,0FEh,0FEh,0FEh,0FFh,0FFh,0FFh,0FFh,0FFh       endifcursprites=0x5b00        ;DS 256        DISPLAY "tables end=",$,"<",distbuftscalesw3	incbin "scalesw3"initproc        ;DS #8000-$        ds imstackbegin-$drawhudhealthcolumncount;e=health;a=health left value        ld c,1drawhudhealthcolumncount0        cp e        rl c        inc a        jr nc,drawhudhealthcolumncount0        retdraw99        ld bc,10-256        inc b        sub c        jr nc,$-2        add a,c        push af        ld a,b        call draw9        pop afdraw9        push hl       if LOWHUD       ld b,a       endif        add a,a        add a,a        add a,a       if LOWHUD       sub b       endif        ld hl,sprdigits        add a,l        ld l,a        jr nc,$+3        inc h        call drawsprchr        pop hl        retdrawhuddot        if doublescr        call drawhuddot_1scr        set 7,bdrawhuddot_1scr        endif        ld a,(bc)        or 0x80        ld (bc),a        retx4_ince_drawsprchr2        call x2_ince_drawsprchr2x2_ince_drawsprchr2        call ince_drawsprchr2ince_drawsprchr2        inc edrawsprchr2        call drawsprchrdrawsprchr        if doublescr        push de        push hl        set 7,d        call drawsprchr_1scr        pop hl        pop dedrawsprchr_1scr        endif        push de        ld b,8-LOWHUDdrawsprchr0        ld a,(hl)        ld (de),a        inc hl        inc d        djnz drawsprchr0        pop de        inc e        ret        display "render vars=",$;переменные рендера (обновляются в начале рендера)curXxcurx    DB #80curX    DB #0curYycury    DB #80curY    DB #0curxy   DW 0curyx   DW 0curYX   DW 0curangle        DW tsin;тут ещё стек	ds imer-$	include "int.asm"        ;DS ((IMER/256+1)<<8)-$	;ds (IMER&0xff00)-$        ds 0x8000-$ ;ORG #8000imvec        DS 257,imer&0xff        INCLUDE "zxloop.asm"        INCLUDE "WSCAN10.asm"        INCLUDE "WREND.asm"badmonstexture	db 0xc0,0xff        align 256t1x        db 255        dup 255        db (255*2/($&0xff)+1)/2        edup        DISPLAY "48K PROG END=",$        ORG initproc	include "recmap.asm"        DS distbuf+#300-$;;;;;        ORG scrbufGO	;xor a	;out (0xfe),a      if 0        DI        LD HL,WAStcos        LD DE,tcos       PUSH DE        LD BC,256        LDIR       POP HLREtcos0       DUP 2;4        SRA (HL)       EDUP        INC L        jr nz,REtcos0      endif        LD HL,imvec        LD DE,imvec+1        LD (HL),imer/256        LD B,E,C,L        LD A,H        LDIR        LD I,A        IM 2        EI       HALT        LD HL,-2        ADD HL,SP        LD (clscrbufsp),HL        LD (eorfillsp),HL	ld hl,ZXLOOP	push hl        LD BC,#FBDF        IN A,(C)        LD (mouseoldx),A        JP RECMAP ;->ZXLOOP	display "ZXLOOP=",ZXLOOPWASMAP       IF invmap;atm        INCBIN "mapatm.E"       ELSE        INCBIN "map48.E"       ENDIFszMAP=$-WASMAP      if 0WAStcos        INCBIN "cos"      endifinit	if mouse	call initmouse	endif;prepare 48K block        DI ;IY        LD HL,#5800        LD DE,#5801        LD BC,767        LD (HL),L        LDIR        call gettexpg       if doublescr       LD A,0x10+pgtmp       call SETPG        call gettexpg       endif       IF music && !atm        call SETPGmusic_silent        CALL #c000 ;init mus       ENDIF       if doublescr       LD A,0x10       call SETPG       endif        LD IY,23610        EI       JP GO ;там recmap, внутри INICLSgettexpg        ld hl,wasgoods        ld de,0x4000        ld bc,0x1000        ldir        ld de,0xb000        ld bc,0x1000        ldir        ld hl,0xffff-0x2000        ld de,0xffff        ld bc,0x2000        lddr        LD HL,0x2000+waswalls;#C000	call copyscrcolumns_2k        LD DE,#C000+0x80;maxscale+1       LD HY,d;0xc0;#FE;4 upper textures = #09A6;4 lower textures = #0AAC        LD HL,0x5000        CALL GETTEX        CALL GETTEX        CALL GETTEX        CALL GETTEX        LD HL,0x2000+waswalls+0x800;#C000	call copyscrcolumns_2k        LD HL,0x5000        CALL GETTEX        CALL GETTEX        CALL GETTEX        CALL GETTEX        LD HL,0x2000+waswalls+0x1000;#C000	call copyscrcolumns_2k        LD HL,0x5000        CALL GETTEX        CALL GETTEX         CALL GETTEX         CALL GETTEX        ;walls: [e2b8] (e3b4 8spr, e274 4spr?), walls2: (eef6 8spr, ec88 4spr?)        ;LD HL,wasgoods	;call copyscrcolumns_4k      if sprites       LD HL,0x4000       CALL GETSPR       LD HL,0x4400       CALL GETSPR       LD HL,0x4800       CALL GETSPR       LD HL,0x4c00       CALL GETSPR        ;LD HL,wasgoods+0x1000;#C000	;call copyscrcolumns_4k        ;jr $      if spritesinpg==8       LD HL,0xb000       CALL GETSPR       LD HL,0xb400       CALL GETSPR       LD HL,0xb800       CALL GETSPR       LD HL,0xbc00       CALL GETSPR      endif      endif	;jr $ ;walls: с оптимизацией f699(f4c0) (12 шт+4 спрайта без оптимизации(с оптимизацией)), (fdbd 8spr, fb6f 4spr?) walls2: 00f4(febd), (0cc0 8spr, 07d6 4spr?)	;jr $ ;пак 7: с оптимизацией de=ec70[ebdf] (f4c8 12 шт)	;jr $ ;пак 3: с оптимизацией de=e1e4[de70]	;jr $ ;пак 2: с оптимизацией de=f070[f6cd]	;jr $ ;пак 1: с оптимизацией de=efdf[ef76, без оптимизации f256]        ;jr $ ;pg1:ec86 ;pg2:e2a6	if 1;исправляем переполнения адресов текстур (адреса в ПЗУ заменяем на 0xc080, а для спрайтов на badmonstexture)	ld h,0xc0fixtexoverflow0	ld l,0x40fixtexoverflow1	ld e,(hl)	inc h	ld d,(hl)	bit 7,d	jr nz,$+5 ;не в ПЗУbadaddrpatch=$+1	 ld de,0xc080	ld (hl),d	dec h	ld (hl),e	inc l	jp p,fixtexoverflow1	inc h	inc h	ld de,badmonstexture	ld a,h	cp 0xc0+(2*texturesinpg)	jr c,$+6	 ld (badaddrpatch),de	cp 0xc0+(2*(texturesinpg+spritesinpg))	jr nz,fixtexoverflow0	endif;составляем таблицу масштабирования	ld hl,tscalesw3	ld c,0	ld b,64initscales0	ld e,(hl)	inc hl	ld d,(hl)	inc hl	push hl	ld l,c	push bc	ld b,d	ld c,e ;adder 8.8;надо из 0040...0400 сделать 78..00 до начала(0x80 -08..-80) = 0x80 - adder*32;надо из 0040...0400 сделать 78..04 в начале (0x80 -08..-7c) = 0x80 - adder*31;...;надо из 0040...0400 сделать 87..f4          (0x80 +07..+74);надо из 0040...0400 сделать 88..f8 в конце  (0x80 +08..+78)	dup 5	sla e	rl d	edup	xor a	sub e	ld e,a	ld a,0x80	sbc a,d	ld d,a ;0x80 - adder*32	ld h,0xc0	ld (hl),0 ;зачем? при d виснет из-за спрайтов	inc hinitscales1	ex de,hl	add hl,bc	ex de,hl	ld (hl),d ;Ys=(Y/32-1)*sc	inc h	jr nz,initscales1	pop bc	inc c	pop hl	djnz initscales0        LD H,#C1INIRETAB0 ;        LD L,0        LD B,maxscale+1INIRETAB1 ;        LD A,(HL)        CP 128-(scrhgtpix/2)        jr nc,$+4        LD A,128-(scrhgtpix/2)        CP 128+(scrhgtpix/2);-1        jr c,$+4       ;LD A,128+(scrhgtpix/2)-1 ;видно линию внизу от переполн-й       LD A,0xff&(dropline-(scrbuf+(scrhgtpix/2)-128))        ADD A,+(0xff&scrbuf)+(scrhgtpix/2)-128        LD (HL),A        INC L        DJNZ INIRETAB1        INC H        LD A,H        INC A ;#C0XX,#FFXX не трогаем        jr nz,INIRETAB0       LD HL,#FF00       LD DE,#FF01       LD BC,maxscale       LD (HL),1       LDIR        ret	if mouseinitmouse	ei	halt      ;задержка, чтобы мышка успевала опознаваться - min 2500 тактов для Evo (компа с 280к тактов быстродействия)      LD B,75prosirtime      LD DE,(0)        ;20 тактов      DJNZ prosirtime  ;13 тактов  ld a, 0x90  out (0x7F), a  out (0x5F), a  ld bc, 0x0FFDF  in h, (c)  ld b, 0x0FB  in l, (c)  dec b  in a, (c)  cp l  ret nz ;jr nz, @detected  cp h  ret nz ;jr z, @comeon        LD A,0xaf ;xor a        LD (mouseon),A        ;ld hl,0x18+(256*readmousejr) ;"jr"        ;ld (readmouse_patch),hl        ret	endifcopyscrcolumns_2k        push de        ld de,0x5000        ld bc,0x800        ldir        pop de	retGETTEX       IF scale64        LD LY,#40       ELSE        LD LY,#80       ENDIF        LD BC,#0880 ;B=width/8, C=#80(mask)GETTEX00 ;       PUSH BCGETTEX0        push hl        CALL GETTEXLINE        pop hl        INC LY       IF scale64 == 0       INC LY       ENDIF        RRC C        jr nc,GETTEX0        ;INC L        ld bc,64        add hl,bc       POP BC        DJNZ GETTEX00       inc hy,hy;DEC HY,HY        RETGETSPR        ;jr $       IF scale64        LD LY,#40       ELSE        LD LY,#80       ENDIF        LD BC,#0880 ;B=width/8, C=#80(mask)GETSPR00 ;       PUSH BCGETSPR0        push hl        CALL GETSPRLINE        pop hl        INC LY       IF scale64 == 0       INC LY       ENDIF        RRC C        jr nc,GETSPR0        ;INC L        ld bc,128;64        add hl,bc       POP BC        DJNZ GETSPR00       inc hy,hy;DEC HY,HY        RETGETTEXincD        call GETincD       JR GETTEXRETRYGETTEXLINE       PUSH HLGETTEXRETRY ;       LD (gettexDE),DE ;linelength addr       POP HL       PUSH HL        LD (IY),E       IF scale64 == 0       LD (IY+1),E       ENDIF        INC HY        LD (IY),D       IF scale64 == 0       LD (IY+1),D       ENDIF        DEC HY       inc e       dec e       jr z,GETTEXincD        INC E        ;jr z,GETTEXincD        LD LX,0;C ;bit        LD HX,17 ;17-pixels        LD B,62 ;62..1 -> 1..62GETTEX1 ;        inc hl;CALL DHL        LD A,(HL)        AND C        CP LX        LD LX,A        jr z,GETTEXN       LD A,HX       OR A       jr z,GETTEXN ;can't add more pixels       inc e       dec e       jr z,GETTEXincD        LD A,tscale/256+63        SUB B        LD (DE),A        DEC HX ;17-pixels        INC E ;todo check before write        ;jr z,GETTEXiDGETTEXN ;        DJNZ GETTEX1        LD A,HX ;17-pixels        ADD A,A        ADD A,A        ADD A,A        SUB HX  ;(17-pixels)*7       ADD A,DWJP&0xffgettexDE=$+1        LD (0),A	ld a,17+1	sub hx ;17+1-(17-pixels)        ld (gettexB),a ;size=1+pixels (min=2 из-за линии пола)       POP HLGETTEX_cmp ;сравнение с предыдущими столбцами	 push de	 push iyGETTEX_cmpnext	ld hl,(gettexDE)	ld a,ly	cp 0x40 ;ниже этого tscales	jr nz,GETTEX_cmpgo	ld a,hy	cp 0xc0	jr z,GETTEX_endcmp	ld ly,0x80;7f	dec hy,hyGETTEX_cmpgo	dec ly	ld e,(iy)	inc hy	ld d,(iy)	dec hy	;ld a,17+1	;sub hx ;17+1-(17-pixels)gettexB=$+1	ld b,0;a ;size=1+pixels (min=2 из-за линии пола)GETTEX_cmp1	ld a,(de)	cp (hl)	jr nz,GETTEX_cmpnext	inc hl	inc de	djnz GETTEX_cmp1;поставить ссылку на прошлую копию	ld e,(iy)	inc hy	ld d,(iy)	 pop iy	 pop af;de        LD (IY),e        INC HY        LD (IY),d        DEC HY	ld de,(gettexDE) ;откатить DE	retGETTEX_endcmp	 pop iy	 pop de        RETGETSPRincD        call GETincD        JR GETSPRRETRYGETSPRLINE       PUSH HLGETSPRRETRY ;       LD (gettexDE),DE ;linelength addr       POP HL       PUSH HL        LD (IY),E       IF scale64 == 0       LD (IY+1),E       ENDIF        INC HY        LD (IY),D       IF scale64 == 0       LD (IY+1),D       ENDIF        DEC HY       ld a,l       add a,2*62       ld l,a ;line 62        LD HX,1        ld lx,2 ;sizeGETSPR1 ;        CALL FIND10        jr nc,GETSPRQ ;end of column       inc e       dec e       jr z,GETSPRincD        LD A,HX        CPL        LD (DE),A ;Y         inc lx        INC E        ;jr z,GETSPRiD        CALL FIND1HEIGHT       inc e       dec e       jr z,GETSPRincD        LD A,HX        CPL        LD (DE),A ;Y2         inc lx        INC E        ;jr z,GETSPRiD        CALL FIND0HEIGHT       inc e       dec e       jr z,GETSPRincD        LD A,HX        CPL        LD (DE),A ;Y3         inc lx        INC E        ;jr z,GETSPRiD        JR GETSPR1GETSPRQ       inc e       dec e       jr z,GETSPRincD        LD A,#C0        LD (DE),A        INC E        ;jr z,GETSPRiD       inc e       dec e       jr z,GETSPRincD        LD A,#FF        LD (DE),A        INC E        ;jr nz,$+5        ; INC D        ; LD E,maxscale+1       POP HL        ld a,lx        ld (gettexB),a        jp GETTEX_cmp ;сравнение с предыдущими столбцамиGETincD        INC D       LD E,0x80;maxscale+1       ld a,d       cp 0xc0+(2*(texturesinpg+spritesinpg))       jr c,$+4;GETSPRRETRY       ld e,0x40 ;дальше нет таблиц адресов       retmaxVhgt=12;14;10 ;при максимальном увеличении (в 4 раза) должно отрисовывать не более maxlinehgt=59 пикселей! (TODO почему 13,14 глючат???);HX=V;HL=maskFIND10        LD A,HX        CP 63        RET Z ;CY=0: end of column        CALL GETPIXEL        RET C ;CY=1: pixel        dec hl;CALL UHL         dec hl        INC HX ;V        JR FIND10FIND1HEIGHT       ;LD LX,HX ;oldV        LD B,0F1H0    CALL GETPIXEL        RET NC ;transparent        RET Z ;0        dec hl;CALL UHL         dec hl        INC HX ;V        INC B        LD A,B        CP maxVhgt        jr c,F1H0        RETFIND0HEIGHT       ;LD LX,HX ;oldV        LD B,0F0H0    CALL GETPIXEL        RET NC ;transparent        RET NZ ;1        dec hl;CALL UHL         dec hl        INC HX ;V        INC B        LD A,B        CP maxVhgt        jr c,F0H0        RETGETPIXEL        LD A,HX        CP 63        RET Z ;CY=0: transparent        inc l;set 1,h;SET 3,L        LD A,(HL)        dec l;res 1,h;RES 3,L        AND C        RET NZ ;CY=0: transparent        LD A,(HL)        AND C        SCF ;CY=1: pixel (Z)        RET        if 0UHL        LD A,H        DEC H        AND 7        RET NZ        LD A,L        SUB #20        LD L,A        RET C        LD A,H        ADD A,8        LD H,A        RET        endif;endall        display "end init=",$        DS 0xb000-$        DS #C000-$	if 0        ;ORG #C000       IF scale64       IF scale64 == 3        INCBIN "tscale3"       ELSE        INCBIN "tscale2"       ENDIF       ELSE        INCBIN "tscale"       ENDIF	endif;hicode_begin	;ds 0x10000-0x1800-0x0800-$ ;0xс040..7f содержит таблицы адресов текстуры (16 текстур?)	ds 0x10000-0x1800-0x2000-$ ;0xс040..7f содержит таблицы адресов текстуры (16 текстур?)waswalls        incbin "walls.bin"wasgoods        incbin "goods.bin";hicode_endend	page pgtmp        org 0xc000hicode_begin        ds 0x10000-0x1800-0x2000-$;waswalls        incbin "walls2.bin";wasgoods        incbin "goods2.bin"hicode_end	page pgmusic        org 0xc000hicode2_begin        include "../../_sdk/ptsplay.asm"MDLADDR        incbin "testmusi.pt3"hicode2_end        page 0       if doublescr	savebin "code.c",begin,end-begin        page pgtmp	savebin "hicode.c",hicode_begin,hicode_end-hicode_begin        page pgmusic	savebin "hicode2.c",hicode2_begin,hicode2_end-hicode2_begin       else	savebin "code.c",begin,hicode_end-begin       endif	LABELSLIST "../../../us/user.l",1