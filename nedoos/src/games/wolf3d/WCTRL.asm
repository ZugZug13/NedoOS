tkeyangle=$-5              ;LRDU       ;DB -1 ;0000       ;DB 128;0001       ;DB 0  ;0010       ;DB -1 ;0011       ;DB 64 ;0100        DB 96 ;0101        DB 32 ;0110        DB 64 ;0111        DB 192;1000        DB 160;1001        DB 224;1010        DB 192;1011        DB -1 ;1100        DB 128;1101        DB 0  ;1110        DB -1 ;1111tkeyangleendinctime        ld hl,leveltime        inc (hl) ;frames        ld a,(hl)        sub 25        ret nz        ld (hl),a        call invalidatehud        inc hl        inc (hl) ;sec        sub 60        ret nz        ld (hl),a        inc hl        inc (hl) ;min        ret;в 0x4000 включена pgmapmy_logic        call inctime        LD HL,(IMcurXx+1)        LD a,(IMcurYy+1)        ld h,a        ;корректировать адрес стены в зависимости от направления        ld a,(IMavision+1)        sub 32        cp 64        jr nc,$+3         inc h        bit 6,a        jr z,$+4         SET mapdifbit,L        cp -64        jr c,$+3         inc l        ld (touchedwalladdr),hl       if EDITOR        ld a,0xf7        in a,(0xfe)        and 0x1foldeditkeys=$+1        ld c,0        ld (oldeditkeys),a        cp c        jr z,noedit        ld c,a        bit 0,c        jr nz,noedit1        ld a,(hl)        or a        ld (hl),0xc0        jr z,edit1q         set 6,a        add a,2        cp 0xc0+(2*12)        jr c,$+4        ld a,0xc0         xor (hl)         and 0x3f         xor (hl)        ld (hl),aedit1qnoedit1        bit 1,c        jr nz,noedit2        ld a,(hl)        or a        ld (hl),0xc0        jr z,edit2q         set 6,a        sub 2        cp 0xc0        jr nc,$+4        ld a,0xc0+(2*11)         xor (hl)         and 0x3f         xor (hl)        ld (hl),aedit2qnoedit2        bit 2,c        jr nz,noedit3        ld a,(hl)        xor 1 ;mirror        ld (hl),anoedit3        bit 3,c        jr nz,noedit4        ld (hl),0noedit4        bit 4,c        jr nz,noedit5        ld a,(hl)        or a        jr z,noedit5        xor 64 ;page        ld (hl),anoedit5noedit       endif       if music        ld a,0xfb        in a,(0xfe)        and 0x1foldtunekeys=$+1        ld c,0        ld (oldtunekeys),a        cp c        jr z,notune        bit 4,a        jr nz,notune       if !atm ;TODO atm        halt        call SETPGmusic_silent        ld hl,playmusicflag        ld a,(hl)        xor 0xcd^0x21        ld (hl),a        call 0xc008;MUTE       endifnotune       endif;режимы двери:;0: дверь закрыта;1: дверь открывается, doortimer увеличивается;2: дверь открыта, dooropentimer уменьшается;3: дверь закрывается, doortimer уменьшаетсяdoortimer=$+1        ld a,0doortimermode=$+1        ld b,0        djnz control_door_noopening        add a,2*LOGICSPEED        ld (doortimer),a        jr nz,control_doorq        dec a ;-1        ld (doortimer),a ;stay opened        ld a,50 ;a=door open time        ld (dooropentimer),a        ld a,2        ld (doortimermode),a        jr control_doorqcontrol_door_noopening        djnz control_door_noopeneddooropentimer=$+1        ld a,0        dec a        ld (dooropentimer),a        jr nz,control_doorq        ;call closecurrentdoor ;keeps hl        ld a,-2*LOGICSPEED        ld (doortimer),a ;stay opened        ld a,3        ld (doortimermode),a        jr control_doorqcontrol_door_noopened        djnz control_door_noclosing;если игрок стоит в дверях, то не закрываем, а открываем        LD HL,(IMcurXx+1)        LD a,(IMcurYy+1)        ld h,a        ld a,ID_DOOR        cp (hl)        jr z,control_door_setopened        inc h        cp (hl)        jr z,control_door_setopened        dec h        set mapdifbit,l        cp (hl)        jr z,control_door_setopened        inc l        cp (hl)        jr z,control_door_setopened        ld a,(doortimer)        sub 2*LOGICSPEED        ld (doortimer),a        jr nz,control_doorq        ;xor a        ld (doortimermode),a        call closecurrentdoor ;keeps hl        jr control_doorqcontrol_door_setopened        ld a,1        ld (doortimermode),acontrol_door_noclosingcontrol_doorq       IF kempston        LD C,#FF        IN A,(#1F)        LD B,A        AND #E0        jr NZ,nKEMPSTON        LD A,B        RRA        jr NC,$+4        RES 1,C        RRA        jr NC,$+4        RES 0,C        RRA        jr NC,$+4        RES 3,C        RRA        jr NC,$+4        RES 2,C        RRA        jr NC,$+4        RES 6,CnKEMPSTON;C=%1f11durl       ENDIF;autostrafe было тут (только для кемпстона)        LD B,#FF        ld a,#fe        in a,(#fe)        rra        rl b ;cs (open)        LD A,#7F        IN A,(#FE)        RRA        RL B ;space (fire)        LD A,#FD        IN A,(#FE)        RRA        RL B ;A        RRA        RRA        RL B ;D        RLA        RL B ;S (down)        LD A,#FB        IN A,(#FE)        RRA        RRA        RL B ;W (up)        LD A,#DF        IN A,(#FE)        RRA        RL B ;P (right)        RRA        LD A,B        RLA ;O (left)       IF kempston        AND C       ENDIF;A=%ofADdurl       IF autostrafe        BIT 3,a ;down        jr NZ,nAUTOSTRAFE        ;LD A,C        BIT 1,A        jr NZ,$+6        AND %11101111 ;strafe        ;AND %01101111 ;strafe + rotate flag        OR %00001011 ;block down & rotate        BIT 0,A        jr NZ,$+6        AND %11011111 ;strafe        ;AND %01011111 ;strafe + rotate flag        OR %00001011 ;block down & rotate        ;LD C,AnAUTOSTRAFE        ld hl,downtimer_timedowntimer_oldkey=$+1        ld b,0xff        ld (downtimer_oldkey),a        cp b        jr z,downtimer_nevent        cp %11110111 ;down only        jr nz,downtimer_ndown        ld b,(hl) ;время от прошлого нажатия        ld (hl),16/LOGICSPEED        dec b ;если счётчик истёк, то не даблклик        jr z,downtimer_ndown ;счётчик истёк        ld a,%01111111 ;grenade onlydowntimer_ndowndowntimer_nevent        dec (hl)        jr nz,$+3        inc (hl)       ENDIF       IF demoplaydemoplayoff=$        OR A        jr C,demoplayQ       BIT 4,A ;"D"       jr NZ,demoplaynOFF        LD A,#37 ;scf        LD (demoplayoff),A        LD A,#91 ;sub c        LD (mouseon),A        LD A,#FFdemoplaynOFFdemocursor=$+1        LD HL,demobegindemokey=$+1        LD A,%00111111demokeytime=$+1        LD C,1        DEC C        jr NZ,CnNEWKEY        LD A,(HL)        LD (demokey),A        INC HL        LD C,(HL)        INC HL        LD (democursor),HLCnNEWKEY        LD HL,demokeytime        LD (HL),CdemoplayQ       ELSE       IF demorecdemocursor=$+1        LD HL,demobegindemokeytime=$+1        LD C,0        INC C        jr Z,CNEWKEY        CP (HL)        jr Z,CnNEWKEYCNEWKEY        INC HL        LD (HL),C        LD C,0        INC HLCnNEWKEY        LD (HL),A        LD (democursor),HL        LD HL,demokeytime        LD (HL),C       ENDIF       ENDIF;a=%ofADdurl       PUSH AF        ;bit 7,a        ;jr nz,noopendoor        ;call closecurrentdoor ;keeps hl        ;LD HL,(IMcurXx+1)        ;LD a,(IMcurYy+1)        ;ld h,atouchedwalladdr=$+1        ld hl,0        ld c,ID_DOOR*2        ld a,(hl)        add a,a        cp c        jr nz,noopendoor        bit mapdifbit,l        jr z,opendoor_hopendoor_l        push hl        res 7,(hl)        inc l        ld a,(hl)        add a,a        cp c        jr z,opendoorok        dec l        dec l        ;ld a,(hl)        ;add a,a        ;cp c        jr opendoorokopendoor_h        push hl        res 7,(hl)        inc h        ld a,(hl)        add a,a        cp c        jr z,opendoorok        dec h        dec h        ;ld a,(hl)        ;add a,a        ;cp copendoorok        res 7,(hl);ничего не делать, если hl==(oldopendooraddr2)       ld de,(oldopendooraddr2)       or a       sbc hl,de       add hl,de        pop de       jr z,noopendoor        call closecurrentdoor ;keeps hl,de        ld (oldopendooraddr2),hl        ld (oldopendooraddr),de        xor a        ld (doortimer),a        inc a        ld (doortimermode),a        ld a,5 ;open sfx        call sfxplaynoopendoor       pop af;сколько фреймов прошло с прошлого fire? считать независимо от fire!        ld hl,firedelaycounter        dec (hl)        jp p,nofire;a=%ofADdurl       bit 6,a       jp nz,nofire        ld hl,bullets        ld b,(hl)        inc b        dec b        jp z,nofire        dec (hl)       push af        ;push hl        ld a,1 ;shot sfx        call sfxplay        ;pop hl       if sprites        call RAYPREPXY        LD l,SCRWIDPIX/2;0x40;TODO связано с scrwid/2        ;ld a,l        ;LD (cura),A        CALL RAYCASTl;C=dist(scale#);B=texx        ld a,c        ld (fire_walldist),a       if 1==0       call getuser_scr_high_cur       SETPG8000       ld a,(fire_walldist)       ld hl,0x8000       ld bc,40       dup 8       ld (hl),7       rla       rr (hl)       add hl,bc       edup       endif        call SCANMONS;в cursprites лежат данные о видимых спрайтах (от задних к передним);ID 8 (0=end);dist 16;xscr 8;monster index        ld hl,curspritesfire_scan0        ld a,(hl)        or a        jp z,fire_scan0q        inc l        ld c,(hl)        inc l        ld b,(hl) ;bc=dist        ld d,b        ld e,c        inc l        dup 4;3;4        srl d        rr e        edup        ld a,d        or a        jr z,$+4         ld e,255        or e        jr nz,$+3         inc e        ld d,t1x/256        ld a,(de) ;width*k (for typical sprite width)        ld e,a        ld a,(hl) ;xscr (центр = 0x40)        sub e        jr nc,$+3         xor a ;a=sprite left margin        cp SCRWIDPIX/2;0x40;TODO связано с scrwid/2        jp nc,fire_miss        ld a,(hl) ;xscr        add a,e        jr nc,$+3         sbc a,a ;a=sprite right margin        cp SCRWIDPIX/2;0x40;TODO связано с scrwid/2        jr c,fire_miss        push hl;не убивать, если стена впереди закрывает монстра (т.е. стена ближе);bc=dist;приводим к 128..255        LD DE,#000        INC B        DEC B        LD A,C        jr Z,fire_MOTOLOGRLQ       ;DUP 5;6MOTOLOGRLloop        INC D        SRL B        RRA        jr nz,MOTOLOGRLloop        ;jr Z,fire_MOTOLOGRLE       ;EDUPfire_MOTOLOGRLQ ;fire_MOTOLOGRLE ;        LD C,A ;128..255 ;D=0..5        LD B,tlogd/256        LD A,(BC) ;log(dist) = 128..255 for arg>=128       if atm==0       SUB 16;64                 ;0..127 for arg=64..127 ;???       endif        LD C,A                ;0 for arg<64        LD B,tlogd2sca/256         SRA D         RR E ;DE=+0,+#80,..+#300        ex de,hl        ADD HL,BC        LD a,(HL) ;scale#        pop hlfire_walldist=$+1        cp 0        jr c,fire_miss        push hl;найти этого монстра в таблице монстров        inc l        ld l,(hl) ;monster index        ld h,0        add hl,hl        add hl,hl        add hl,hl ;*8        ld bc,MONSTRS+5 ;Xx,Yy,TYPEphase_dir,TIMEenergy        add hl,bc ;TYPEphase        ld b,30;20 ;energy loss        call fire_wound        pop hlfire_miss       if CURSPRITES_RECSZ == 5       inc l       endif        inc l        jp fire_scan0fire_scan0q       endif       pop af        ld hl,firedelaycounter        ld (hl),10nofire;GRENADE;сколько фреймов прошло с прошлого fire? считать независимо от fire!        ld hl,grenadedelaycounter        dec (hl)        jp p,nogrenade;a=%ofADdurl       bit 7,a       jp nz,nogrenade        ld hl,grenades        inc (hl)        dec (hl)        jp z,nogrenade        dec (hl)       push af        ;ld hl,grenades        ;ld b,1        ;call decvariable        ;jr c,nogrenade ;error        call findfreemonster        jr c,popnogrenade ;error        LD de,(IMcurXx)        ld (hl),e        inc l        ld (hl),d        inc l        LD de,(IMcurYy)        ld (hl),e        inc l        ld (hl),d        inc l        ld a,(IMavision+1)        ld (hl),a ;dir        inc l        ld (hl),7*8+0 ;grenade        inc l        ld (hl),10 ;energy (определяет время горения)        ;inc l        ;ld (hl),0 ;TIMEpopnogrenade       pop af        ld hl,grenadedelaycounter        ld (hl),20nogrenade       push afIMavision=$+1        LD HL,32*256IMdavision=$+1        LD DE,100        AND %10110011        CP 0        LD ($-1),A        jr Z,$+4        LD E,50 ;key just pressed/released       IF 0;autostrafe;&kempston        BIT 7,A        jr NZ,nAUTOROTATE        BIT 4,A        jr NZ,AUTOROTATEnr        dup (1+doublerotate)*LOGICSPEED        ADD HL,DE        edupAUTOROTATEnr        BIT 5,A        jr NZ,AUTOROTATEnl        dup (1+doublerotate)*LOGICSPEED        SBC HL,DE        edupAUTOROTATEnlnAUTOROTATE       ENDIF        RRA        jr C,rotatenr        dup (1+doublerotate)*LOGICSPEED        ADD HL,DE        eduprotatenr        RRA        jr C,rotatenl        dup (1+doublerotate)*LOGICSPEED        SBC HL,DE        eduprotatenl        LD A,E        ADD A,20;12;10        jr C,$+3         LD E,A ;key held: increase rotspd        LD (IMdavision),DE       IF mouse        LD BC,#FBDF        IN A,(C)mouseoldx=$+1        LD C,0        LD ($-1),Amouseon=$       IF demoplay        XOR A       ELSE        SUB C       ENDIF        NEG        LD E,A        RLA        SBC A,A        LD D,A        ex de,hl        DUP 6        ADD HL,HL        EDUP        ADD HL,DE       ENDIF        LD (IMavision),HL;делим вектор на коэфф замедленияIMcurDX=$+1        LD HL,0        LD B,H        ld A,L        SRA B        RRA       IF doublespeed        SRA B        RRA       ENDIF        LD C,A        CP B       jr NZ,$+3       LD C,L        SBC HL,BC        LD B,H        ld C,LCSLOWXQIMcurDY=$+1        LD HL,0        LD D,H        ld A,L        SRA D        RRA       IF doublespeed        SRA D        RRA       ENDIF        LD E,A        CP D       jr NZ,$+3       LD E,L        SBC HL,DE        LD D,H        ld E,LCSLOWYQ       POP AF ;%00ADSWPO       RRCA       RRCA       AND 15        LD HL,tkeyangle        ADD A,L        LD L,A       IF (tkeyangle^tkeyangleend)&256        ADC A,H        SUB L        LD H,A       ENDIF        LD A,(HL);прибавляем вектор направления;sin и cos (IMavision+32*N), где N=0..7 в зав. от клавиш;0=forth;64=left       CP -1       JP Z,CTRLnspeed        LD HL,IMavision+1        ADD A,(HL)        LD L,A     if 1       ld h,tsin/256       ld a,(hl)       ld e,a       rla       sbc a,a       ld d,a        LD A,64        SUB L        LD L,A       ld a,(hl)       ld c,a       rla       sbc a,a       ld b,a     else        LD H,tcos/256 ;-pi/4..+pi/4        LD A,(HL)       ADD A,C       LD C,A       BIT 7,(HL)       jr NZ,$+3       INC B       jr C,$+3       DEC B        LD A,64        SUB L        LD L,A        LD A,(HL)       ADD A,E       LD E,A       BIT 7,(HL)       jr NZ,$+3       INC D       jr C,$+3       DEC D     endifCTRLnspeed        LD (IMcurDX),BC        LD (IMcurDY),DE       DUP 2        SRA D        RR E        SRA B        RR C       EDUP        ld b,e        LD HL,(IMcurXx)        LD de,(IMcurYy);hl=x;de=y;c=dx/4;b=dy/4        call moveandcollideX        ex de,hl        call moveandcollideY;hl=y;de=x        LD (IMcurYy),HL        LD (IMcurXx),de;TODO загнать 2 цикла в один?        ;call collideobjects        call movemonsters        ;retcollideobjects;collide with objects;все объекты - в центре своей клетки        LD HL,MONSTRS+1 ;1+начало табл.монстров/предметов        ;ld hx,-1 ;monster index       jp logCOLLIDE0 ;цикл скан-я видимых монстров/предметовlogCOLLIDENx        LD A,L        ADD A,8        LD L,A        JR C,logCOLLIDExIHlogCOLLIDE0       ;inc hx ;monster index        LD A,(HL) ;X        INC A       RET Z        ld a,(IMcurXx+1)        cp (hl)        jr nz,logCOLLIDENx        inc l        inc l        ld a,(IMcurYy+1)        cp (hl)        jr z,logCOLLIDEY        LD A,L        ADD A,6        LD L,A        JP NC,logCOLLIDE0logCOLLIDExIH        INC H        JP logCOLLIDE0logCOLLIDEY        inc l        ;ld a,(hl) ;dir        inc l        ld a,(hl) ;TYPE*8+phase        cp 4*8        jr c,logCOLLIDEnobj        cp 6*8        jr nc,logCOLLIDEnobj        and 0xf8 ;иначе фаза шевелится 0..1        push hl        ;ld a,l        ;and 0xf8        ;ld l,a        ;inc l ;X        res 1,l        res 2,l        ld (hl),0xc0 ;impossible X        ;cp 4*8        ;jr nz,logCOLLIDEnammo        ld hl,bullets        ld bc,40*256+50 ;ADDmaxlogCOLLIDEnammo        cp 5*8        jr nz,logCOLLIDEnhealth        ld hl,health        ld bc,40*256+100 ;ADDmaxlogCOLLIDEnhealth        call addmax        ld a,3 ;get obj        call sfxplay        pop hllogCOLLIDEnobj        inc l        ;ld a,(hl) ;energy        inc l        ;ld a,(hl) ;time        inc hl       INC L ;skip x        jp logCOLLIDE0;bc=y;de=xwoundneighbours        ld a,d        SUB woundrange        LD (woundXbase),A        ld a,b        SUB woundrange        LD (woundYbase),A        LD HL,MONSTRS+1 ;1+начало табл.монстров/предметов        ;ld hx,-1 ;monster index       jp wound0 ;цикл скан-я видимых монстров/предметовwoundNx        LD A,L        ADD A,8        LD L,A        JR C,woundxIHwound0       ;inc hx ;monster index        LD A,(HL) ;X        INC A       RET ZwoundXbase=$+1        SUB 0        CP woundrange*2+1        JP NC,woundNx        INC L        inc L        LD A,(HL)woundYbase=$+1        SUB 0        CP woundrange*2+1        JR C,woundY        LD A,L        ADD A,6        LD L,A        JP NC,wound0woundxIH        INC H        JP wound0woundY        DEC L        dec L        dec L        LD C,(HL)        INC L        LD B,(HL) ;Xx        INC L        LD E,(HL)        INC L        LD D,(HL) ;Yy        INC L        inc l ;skip dir        push hl        ld b,100;hl=@TYPEphase;b=energy loss        call fire_wound        pop hl        inc l ;skip TYPEphase        inc l ;skip energy        inc hl ;skip TIME       INC L ;skip x        jp wound0movemonsters;move monsters        LD A,(IMcurXx+1);d;(curX)        SUB viewrange        LD (logscmonX),A        LD A,(IMcurYy+1);h;(curY)        SUB viewrange        LD (logscmonY),A        LD HL,MONSTRS+1 ;1+начало табл.монстров/предметов        ;ld hx,-1 ;monster index       jp logSCMONS0 ;цикл скан-я видимых монстров/предметовlogSCMONNx        LD A,L        ADD A,8        LD L,A        JR C,logSCMxIHlogSCMONS0       ;inc hx ;monster index        LD A,(HL) ;X        INC A       RET ZlogscmonX=$+1        SUB 0        CP viewrange*2+1        JP NC,logSCMONNx        INC L        inc L        LD A,(HL)logscmonY=$+1        SUB 0        CP viewrange*2+1        JR C,logSCMONY        LD A,L        ADD A,6        LD L,A        JP NC,logSCMONS0logSCMxIH        INC H        JP logSCMONS0logSCMONY        DEC L        dec L        dec L       push hl ;objaddr        LD C,(HL)        INC L        LD B,(HL) ;Xx        INC L        LD E,(HL)        INC L        LD D,(HL) ;Yy        INC L        ld a,(hl) ;dir       inc l       ex af,af' ;'       ld a,(hl) ;TYPEphase       ex af,af' ;'        or a        jr z,logSCMONS_nomove       push af ;dir        push bc ;x        ld l,a     if 1       ld h,tsin/256       ld b,(hl)        LD A,64        SUB L        LD L,A       ld c,(hl)       dup 2       sra b       sra c       edup     else        LD H,tcos/256 ;-pi/4..+pi/4        LD c,(HL)        LD A,64        SUB L        LD L,A       ;ld a,b ;TYPEphase        LD b,(HL)     endif        pop hl ;x       ex af,af' ;'       cp 7*8 ;grenade       jr nc,movemons_noslow        dup 2;3        sra b        sra c        edupmovemons_noslow       ex af,af' ;';hl=x;de=y;c=dx/4;b=dy/4        call moveandcollideX        ex de,hl        call nc,moveandcollideY;hl=y;de=x       pop bc ;b=dir       ld a,b       jr nc,movemons_nochagedir       ld a,r ;TODO rnd       add a,a       inc a       ex af,af' ;'       cp 7*8 ;grenade       jr c,movemons_chagedir_ngrenade       ex (sp),hl ;pop objaddr       push hl ;objaddr       ;jr $       set 2,l       ;ld (hl),0 ;dir=no move       inc l       ld (hl),7*8+4 ;ammo wounded ;explode        inc l        ;ld (hl),a ;energy        inc l        ld (hl),TIME_WOUNDED ;time;TODO ранить себя        push bc ;b=dir        push de        ;jr $       res 2,l       ld b,(hl)       dec l       ld c,(hl);bc=y;de=x        call woundneighbours        ld a,6 ;explode        call sfxplay        pop de        pop bc ;b=dir       pop hl ;objaddr       ex (sp),hl ;push objaddr       ;ex af,af' ;'       xor a ;dir=no move       ex af,af' ;'movemons_chagedir_ngrenade       ex af,af' ;'movemons_nochagedir        ld b,d        ld c,e ;x        ex de,hl ;ylogSCMONS_nomove       pop hl ;objaddr        ld (hl),c       ld lx,c        inc l        ld (hl),b ;Xx        inc l        ld (hl),e       ld hx,e        inc l        ld (hl),d ;Yy        inc l        ld (hl),a ;dir        inc l ;skip dir      if 1      ;ld a,0xfe      ;in a,(0xfe)      ;rra      ;jr c,logSCMONS_noattack;если (1..3)*8+(0..1) и близко, то wantattack:        ld a,(hl) ;TYPE*8+phase        and (30*8)+6        cp 0*8+0 ;стоит спиной        ld e,MONSTERBACKviewrange        jr z,logSCMONS_startattack        cp 2*8+0 ;стоит лицом или идёт        ld e,MONSTERviewrange        jr nz,logSCMONS_noattacklogSCMONS_startattack        ld a,(IMcurYy+1)        sub d ;Y        jr nc,$+4        neg        cp e;MONSTERviewrange        jr nc,logSCMONS_noattack        ld a,(IMcurXx+1)        sub b ;X        jr nc,$+4        neg        cp e;MONSTERviewrange        jr nc,logSCMONS_noattack       ;ld a,(hl) ;TYPE*8+phase        ld (hl),3*8+2 ;wantattack        inc l        inc l        ld (hl),TIME_WANTATTACK        dec l        dec l        push hl;чтобы кричать только первый раз:       ;cp 0*8+0       ;jr z,doshout ;если стоял спиной, то всё-таки крикнуть       dec l       ld a,(hl) ;dir       or a       jr z,doshout;noshout ;если стоял, то кричать       and 0x3f       dec a ;квадратно-гнездовое направление (изначальное) - кричать, иначе нетdoshout        ld a,4 ;shout        call z,sfxplaynoshout        pop hllogSCMONS_noattack      endif        ld c,(hl) ;TYPE*8+phase        INC L ;skip TYPE*8+phase        inc L ;skip energy        dec (hl) ;time        jp nz,logSCMONS_notime        ;ld (hl),TIME_STEP ;time        ;dec l        ;dec l ;hl points to TYPE*8+phase        ld a,c        and 7        jr z,logSCMONS_step        dec a        jr z,logSCMONS_step        dec a        jr z,logSCMONS_wantattack        dec a ;attack        jr z,logSCMONS_attack        dec a        jr z,logSCMONS_wounded        dec a        jr z,logSCMONS_explode2        jr logSCMONS_nosetphaselogSCMONS_wantattack        ;inc l        ;inc l        ld (hl),TIME_ATTACK        dec l        dec l        dec l        ld (hl),0 ;dir (no move)        inc l        ld a,3*8+3 ;moving attack        jr logSCMONS_setphaselogSCMONS_explode2        ;inc l        ;inc l        ld (hl),TIME_EXPLODE        dec l        dec l       ld a,8*8 ;fire       jr logSCMONS_setphase;logSCMONS_wounded_ammo;       ld a,7*8+6 ;explode2;       jr logSCMONS_setphase;дальше продолжаем движениеlogSCMONS_wounded        ;inc l        ;inc l        ld (hl),TIME_WOUNDED        dec l        dec l       ld a,(hl)       cp 4*8 ;ammo?       ld a,7*8+5 ;explode2       jr nc,logSCMONS_setphase;logSCMONS_wounded_ammologSCMONS_setmoving        ld a,r ;TODO rnd        add a,a ;dir        dec l        ld (hl),a ;dir        inc l        ld a,3*8+0 ;moving        jr logSCMONS_setphase ;not ammologSCMONS_step        ;inc l        ;inc l        ld (hl),TIME_STEP        dec l        dec l        ld a,c        and 0xf8        cp 8*8        jr nz,logSCMONS_noendfire;огонь гасим постепенным уменьшением энергии        inc l        dec (hl)        dec hl        jr nz,logSCMONS_noendfire        res 2,l        ld (hl),0xc0 ;impossible X        set 2,llogSCMONS_noendfire        ld a,c        xor 1logSCMONS_setphase        ld (hl),alogSCMONS_nosetphase        inc l        inc llogSCMONS_notime        inc hl ;skip TIME       INC L ;skip x        jp logSCMONS0;;;;attack!!!!logSCMONS_attack        ;inc l        ;inc l        ld (hl),TIME_SHOT        dec l        dec l;TODO узнать расстояние, чтобы определить, сколько отнять здоровья;todo проверить, что враг нас видит;для этого найти угол, под которым мы видим врага;потом найти евклидово расстояние (OBJMUL, но без коррекции!);и сравнить его с расстоянием в RAYCAST (для этого угла) без коррекции!;[или повернуть виртуальную камеру (на угол, под которым мы видим врага) и делать с коррекцией, обычными процедурами?]       push hl       ld c,lx ;было запорото       ld e,hx ;было запорото       push bc ;monsterXx       push de ;monsterYy        LD HL,(curYy)        ex de,hl        SBC HL,DE ;dYy со стороны монстра        ld (logSCMONS_dYy),hl        ex de,hl;EXD        ld h,b        ld l,c        LD bc,(curXx)        SBC HL,BC ;dXx со стороны монстра        ld (logSCMONS_dXx),hl       ;push de ;dYy       ;push hl ;dXxnormvec0        sra d        rr e        sra h        rr l        ld a,e        rla        sbc a,a        cp d        jr nz,normvec0        ld a,l        rla        sbc a,a        cp h        jr nz,normvec0        ;ld a,l        ;cpl        ;ld b,a ;-x        ld b,l ;x        ;ld a,e        ;cpl        ;ld c,a ;-y        ld c,e ;y;B = x, C = y in -128,127        call atan2;out: A = angle in 0-255;монстр с востока:;de=fffc, hl=00fa [de=0x0039(y), hl=0xfec2(x)];de=fffe, hl=007d [de=0x000e(y), hl=0xffb0(x)] после уменьшения;a=[81]00 (с юго-востока [9c]e8);в рендере: 0x40 смотрим на север, 0x20 на северо-восток, 0x00 на восток, 0xc0 на юг, 0x80 на запад        add a,0x80       pop de ;monsterYy       pop hl ;monsterXx;hl=monsterXx;de=monsterYy;a=monster angle        call RAYPREPXY_hldea ;между делом заполняет curanglelogSCMONS_dXx=$+1        ld hl,0logSCMONS_dYy=$+1        ld de,0;calculate sprite position        CALL OBJMUL       ;BC=dist       ;DE=xscr;BC=dist ;017a с востока ;0058..00ad с юго-востока - ошибка,занижено!!!        call disttoscale;de=dist, c=scale# (0x1a впритык с востока) (3a..2d с юго-востока - ошибка,занижено!!!)       ld a,c       ld (logSCMONS_sprscale),a ;scale#(spr)              LD l,SCRWIDPIX/2;0x40;TODO связано с scrwid/2        ;ld a,l        ;LD (cura),A        CALL RAYCASTl;C=dist(scale#) (0x09 впритык с востока) (30 с юго-востока);B=texx;сравнить dist(raycast) > dist(spr), то есть scale#(raycast) < scale#(spr)        ld a,c ;scale#(raycast)        ;jr $logSCMONS_sprscale=$+1        cp 0;lx ;scale#(spr)        jr nc,logSCMONS_failfire        ld a,7 ;enemy shoot        call sfxplay        ld hl,health        ld b,5;3        call decvariable ;out: z=0, c=errorlogSCMONS_failfire       pop hl        jp logSCMONS_setmoving        ;ld a,3*8+0 ;moving        ;jr logSCMONS_setphase ;not ammomoveandcollideX;hl=x;de=y;c=dx/4;b=dy/4        ;ADD HL,BC       PUSH HL;|..............|;.....<---*--->..        ;or a:sbc hl,bc;LD HL,(IMcurXx)         ld a,l         sub mindist ;dx<0         ;dec h        BIT 7,c;B        jr nz,$+6         ld a,l         add a,mindist ;dx>0         inc h        jr nc,CTRLXpass ;проходимо (CY=0)        ;LD A,H        ;LD HL,(IMcurYy)        ;LD L,A        ld l,h        ld h,d ;Y        SET mapdifbit,L        LD A,(HL)        RLA ;проходимо?CTRLXpass       POP HL        jr nc,CTRLnXq ;проходимо (CY=0)CTRLnX;непроходимо        ;LD HL,(IMcurXx)        BIT 7,c;B        LD l,256-mindist ;dx>0        ret z ;C        LD l,mindist ;dx<0        ret ;CCTRLnXq        ;add hl,bc        ld a,c        add a,l        ld l,a        adc a,h        sub l        ld h,a         or a ;NC        bit 7,c        ret z ;NC        dec h        ret ;NCmoveandcollideY;hl=y;b=dy/4        ;ADD HL,DE       PUSH HL        ;or a:sbc hl,de;LD HL,(IMcurYy)         ld a,l         sub mindist ;dx<0         ;dec h        BIT 7,b;D        jr nz,$+6         ld a,l         add a,mindist ;dx>0         inc h        jr nc,CTRLYpass ;проходимо (CY=0)        ;LD A,H        ;LD HL,(IMcurXx)        ;LD L,H        ;LD H,A        ld l,d ;X        LD A,(HL)        RLA ;проходимо?CTRLYpass       POP HL       jr nc,CTRLnYq ;проходимо (CY=0);непроходимо        ;LD HL,(IMcurYy)        BIT 7,b;d        LD l,256-mindist ;dy>0        ret z ;C        LD l,mindist ;dy<0        ret ;CCTRLnYq        ;add hl,de        ld a,b        add a,l        ld l,a        adc a,h        sub l        ld h,a         or a ;NC        bit 7,b        ret z ;NC        dec h        RET ;NCclosecurrentdoor;keeps hl,de        ld a,128+ID_DOOR;(hl)oldopendooraddr=$+1        ld (killablebyte),aoldopendooraddr2=$+1        ld (killablebyte),a       ld bc,killablebyte       ld (oldopendooraddr),bc       ld (oldopendooraddr2),bc        retkillablebyte        db 0addmax;add b, max c        ld a,(hl)        cp c;100        ret nc        add a,b;40        ld (hl),a        cp c;100        ret c        ld (hl),c;100        retdecvariable;sub b;out: z=0, c=error        ld a,(hl)        or a        ccf        ret z ;error        sub b        jr nc,$+3        xor a        ld (hl),a        retfire_wound;hl=@TYPEphase;b=energy loss        ld a,(hl)        cp 5*8;4*8        ret nc;jr nc,fire_skip ;not a monster/ammo        and 7        cp 6        ret z;jr z,fire_skip ;dead monster        dec l        ld (hl),0 ;dir = no move        inc l       ld a,(hl)       cp 4*8 ;ammo?        ld (hl),3*8+4 ;wounded, go       jr c,$+4 ;not ammo       ld (hl),7*8+4 ;ammo wounded        inc l        ld a,(hl) ;energy        sub b;20        ld (hl),a ;energy        jr c,fire_kill        inc l        ld (hl),TIME_WOUNDED ;time        ld a,2 ;wound sfx        jr fire_killqfire_kill        dec l        ld (hl),3*8+6 ;dead        ;ld a,l        ;and 0xf8        ;ld l,a        ;inc l ;X        ;ld (hl),0xc0 ;impossible X        ld a,0 ;kill sfxfire_killq        jp sfxplay;fire_skip;        retfindfreemonster;out: CY=error, hl=addr        ld hl,MONSTRS ;Xx,Yy,TYPEphase_dir,TIMEenergy ;TYPEphase=TYPE*8+phase;перебрать объекты, вставить на место дохлого (impossible X = 0xc0) или в конецfindfreemonster0        inc l        ld a,(hl)        INC A        jr z,findfreemonsterEND        cp 0xc0+1        jr z,findfreemonsterOK        set 1,l        set 2,l        inc hl        jr findfreemonster0findfreemonsterEND        ld bc,-(ENDMONS-8)        add hl,bc        ret c        sbc hl,bc        ld bc,8        add hl,bc        ld (hl),-1 ;new end marker        sbc hl,bcfindfreemonsterOK        dec l        ret ;NC       if 1; 8-bit atan2; Calculate the angle, in a 256-degree circle.; The trick is to use logarithmic division to get the y/x ratio and; integrate the power function into the atan table.;	input; 	B = x, C = y	in -128,127;;	output;	A = angle		in 0-255;      |;  q1  |  q0;------+-------;  q3  |  q2;      |atan2:		ld	de,0x8000		ld	a,c		add	a,d		rl	e				; y-		ld	a,b		add	a,d		rl	e				; x-		dec	e		jr	z,q1		dec	e		jr	z,q2		dec	e		jr	z,q3q0:		ld	h,log2_tab / 256		ld	l,b		ld	a,(hl)			; 32*log2(x)		ld	l,c		sub	(hl)			; 32*log2(x/y)		jr	nc,1f			; |x|>|y|		neg				; |x|<|y|	A = 32*log2(y/x)1:		ld	l,a		ld	h,atan_tab / 256		ld	a,(hl)		ret	c			; |x|<|y|		neg		and	0x3F			; |x|>|y|		retq1:		xor a;ld	a,b		sub b;neg		ld	b,a		call	q0		neg		and	0x7F		retq2:		xor a;ld	a,c		sub c;neg		ld	c,a		call	q0		neg		retq3:		xor a;ld	a,b		sub b;neg		ld	b,a		xor a;ld	a,c		sub c;neg		ld	c,a		call	q0		add	a,128		ret       endif