       IF crosshair       MACRO XORN n        LD A,(HL)        ;and 0xff-n        XOR n ;рисуем в xor-буфере!        LD (HL),A       ENDM CROSSHAIR        LD HL,scrbuf+((scrwid/2)<<8)+(scrhgtpix/2)        XORN #0F        DEC H        XORN #78        INC L        XORN #78        INC H        XORN #0F        LD L,0xff&(scrbuf+(scrhgtpix/2)-7)        XORN #80        LD L,0xff&(scrbuf+(scrhgtpix/2)-3)        XORN #80        LD L,0xff&(scrbuf+(scrhgtpix/2)+4)        XORN #80        LD L,0xff&(scrbuf+(scrhgtpix/2)+8)        XORN #80        RET        ENDIF ;crosshairCHECKHEIGHTS        LD HL,distbuf+#200 ;dist        LD DE,scrbufflag        LD BC,(scrwid<<8)+lowmaxscalecheckheights0        LD A,C;lowmaxscale_=pixperchr       DUP pixperchr_=_-1        CP (HL)       IF debug       CALL npp       ENDIF         INC L        jr C,checkhigh-_       EDUP         XOR A        JP checklow       DUP pixperchr        INC L       EDUP checkhigh ;A<>0 <128checklow ;A=0        LD (DE),A        INC D        DJNZ checkheights0        RET        IF debugnpp       PUSH AF       PUSH HL        jr C,NNN        LD HL,nlow        INC (HL)        INC HL        jr Z,$-2NNN        LD HL,nstolb        INC (HL)        INC HL        jr Z,$-2       POP HL       POP AF        RET nlow        DS 4nstolb        DS 4       ENDIF        if atm == 0CLSCRBUF        LD H,scrbuf/256        LD BC,scrwid*256+(0xff&scrbufflag)        XOR A        LD D,A        ld E,Aclscrbuf0 ;        LD L,C;scrbufflag        CP (HL)        jr NZ,clscrhigh        LD L,0xff&(lowscrbuf+lowscrhgtpix)        LD SP,HL       IF (0xff&(scrbuf+scrhgtpix)) == 0        INC H       ENDIF         JP clscrlowclscrhigh        LD L,0xff&(scrbuf+scrhgtpix)       IF (0xff&(scrbuf+scrhgtpix)) == 0        INC H       ENDIF         LD SP,HL       DUP scrhgtpix/2        PUSH DE       EDUP clscrlow=$-(lowscrhgtpix/2)-1 ;EORFILL could corrupt a word       IF 0xff&(scrbuf+scrhgtpix)        INC H       ENDIF         DJNZ clscrbuf0clscrbufsp=$+1        LD SP,0        RET        endif       if atm == 0EORFILL       IF doublescr        LD A,(newscr)        SUB 1        SBC A,A        AND #80        XOR scrtop/256        LD (curscrtopH),A        ADD A,+(lowscrtop/256)-(scrtop/256)        LD (curlowscrtopH),A        ADD A,+(attrtop/256)-(lowscrtop/256)        LD (curattrtopH),A        LD (curattrtopH2),A       ENDIF         LD L,scrtop&0xff        LD C,32        EXX         LD H,scrbuf/256        LD DE,+((scrbuf&0xff)*256)+(0xff&lowscrbuf)        LD BC,+(scrwid*256)+(0xff&scrbufflag)eorfill0 ;        LD L,C;scrbufflag        LD A,(HL)        OR A        JP Z,eorfillloweorfillhigh        LD L,D;scrbuf        LD SP,HL        EXX ;EOR-fill столбца на экран:curscrtopH=$+1        LD H,scrtop/256 ;#40       JP M,eorcopy        LD A,L        AND 31       IF scrtop&#E0        ADD A,scrtop&#E0       ENDIF         LD L,A        LD B,-7 ;BC,#F920        XOR A_=scrtop/32      DUP scrhgt ;8       DUP 4        POP DE        XOR E        LD (HL),A        INC H        XOR D        LD (HL),A        INC H       EDUP         ORG $-1__=$        ADD HL,BC_=_+1       IF (_&7) == 0        ORG __        LD B,0 ;BC=#0020        ADD HL,BC        LD B,-7       ENDIF       EDUP         ORG __eorcopyQ;attrs after pixels for no flickering        LD A,L        AND 31       IF attrtop&#E0        ADD A,attrtop&#E0       ENDIF         LD L,AcurattrtopH=$+1        LD H,attrtop/256        LD A,colour        CP (HL)        jr Z,eorfillok        LD B,0 ;BC=32       DUP (scrhgt-lowscrhgt)/2        LD (HL),A        ADD HL,BC       EDUP         ORG $-1        LD DE,32*(lowscrhgt+1)        ADD HL,DE       DUP (scrhgt-lowscrhgt)/2        LD (HL),A        ADD HL,BC       EDUP         ORG $-1eorfillok ;        INC L        EXX         INC H        DEC B        JP NZ,eorfill0eorfillsp=$+1        LD SP,0        RET eorfilllow       ;ex af,af' ;'        LD L,E;lowscrbuf        LD SP,HL        EXX ;EOR-fill низкого столбца на экран:        LD A,L        AND 31       IF attrtop&#E0        ADD A,attrtop&#E0       ENDIF         LD L,A ;сначала замажем атрибутами верхcurattrtopH2=$+1        LD H,attrtop/256        LD A,ceilingcolour        CP (HL)        jr Z,eorfilllownattr ;уже замазано        LD B,0 ;BC=32       DUP (scrhgt-lowscrhgt)/2        LD (HL),A        ADD HL,BC       EDUP         ORG $-1        LD DE,32*(lowscrhgt+1) ;        ADD HL,DE              ;можно add hl,bc:inc h (TODO)        LD A,floorcolour       DUP (scrhgt-lowscrhgt)/2        LD (HL),A        ADD HL,BC       EDUP         ORG $-1eorfilllownattr ;        LD A,L        AND 31       IF lowscrtop&#E0        ADD A,lowscrtop&#E0       ENDIF         LD L,AcurlowscrtopH=$+1        LD H,lowscrtop/256       ;branch to eorcopylow (никогда не происходит)       ;ex af,af' ;'       ;JP M,eorcopylow        LD B,-7 ;BC,#F920        XOR A_=lowscrtop/32      DUP lowscrhgt       DUP 4        POP DE        XOR E        LD (HL),A        INC H        XOR D        LD (HL),A        INC H       EDUP         ORG $-1__=$        ADD HL,BC_=_+1       IF (_&7) == 0        ORG __        LD B,0 ;BC=#0020        ADD HL,BC        LD B,-7       ENDIF       EDUP         ORG __        JP eorfillokeorcopy        LD A,L        AND 31       IF scrtop&#E0        ADD A,scrtop&#E0       ENDIF         LD L,A        LD B,-7 ;BC,#F920        XOR A_=scrtop/32      DUP scrhgt ;8       DUP 4        POP DE        LD (HL),E        INC H        LD (HL),D        INC H       EDUP         ORG $-1__=$        ADD HL,BC_=_+1       IF (_&7) == 0        ORG __        LD B,0 ;BC=#0020        ADD HL,BC        LD B,-7       ENDIF       EDUP         ORG __        JP eorcopyQ       if 0eorcopylow        LD B,-7 ;BC,#F920        XOR A_=lowscrtop/32      DUP lowscrhgt       DUP 4        POP DE        LD (HL),E        INC H        LD (HL),D        INC H       EDUP         ORG $-1__=$        ADD HL,BC_=_+1       IF (_&7) == 0        ORG __        LD B,0 ;BC=#0020        ADD HL,BC        LD B,-7       ENDIF       EDUP         ORG __        JP eorfillok       endifDHL        INC H        LD A,H        AND 7        RET NZ        LD A,L        ADD A,32        LD L,A        RET C        LD A,H        SUB 8        LD H,A        RET        endif       IF atm == 0DRAWWALLS        LD HY,DWJP/256        LD L,0       ;LD DE,distbuf+3        EXX         LD D,scrbuf/256       IF lores == 0        LD C,#80       ELSE         LD C,#C0       ENDIF         LD B,scrwidDW0 ;        EXX         LD H,distbuf/256 ;D ;+3        LD a,(hl);D,(HL) ;ID       RRCA        ADD A,A ;флаг зеркальности в CY ;TODO рисовать уровни так, чтобы при взгляде вверх все были незеркальные, вниз - все зеркальные (тогда и зеркальность не нужно будет хранить?)       set 7,a ;(keep CY) быстрый пересчёт ID_DOOR (открытая дверь < 128)       ld d,a              if doublescr       push af ;SETPG портит CY       bit 6,d       set 6,d       ld a,0x10       jr nz,$+4       ld a,0x10+pgtmp       call SETPG       pop af       endif              ;cp 0xc0       ;jr c,$       ;cp 0xc0+(texturesinpg*2)       ;jr nc,$	;ld d,0xc0+(2*9)       ;IF debug       ; LD A,D       ; CP -20       ; jr NC,$+4       ; LD D,-20       ;ENDIF         INC H        LD a,(hl);E,(HL) ;texx       jr NC,$+3       CPL ;зеркальная      AND 0x3F ;      or 0x40;0x80  ;TODO уже в ray?      ld e,a        INC H        LD A,(DE)        INC D       LD C,A ;+4        LD A,(DE)       LD B,A ;+4       LD A,(BC) ;-12       LD LY,A        LD HX,B        LD LX,C        LD A,(HL) ;dist        INC L        EXX        IF 0;#06..#2B = 38;#2C,#2E..#56 = 22;#58,#5C..#64 = 4;=64 scales       CP #06 ;max=#06       jr NC,$+4       LD A,#06       CP #67       jr C,$+4       LD A,#67       CP #2C ;min=#28       jr C,$+4       AND #FE       CP #58 ;min=#50       jr C,$+4       AND #FC       ENDIF         LD L,A       IF optresfoptfast=$+1        CP lowmaxscale        jr NC,DW0highDW0low ;       LD B,C       ENDIF ;d=столбец;c=битмаска столбца;ix=адрес графики столбца;l=scale       ;LD A,(IX) ;(18-N)*7       ;LD LY,A        JP (IY)       IF optresDW0high ;        LD A,C        AND %10101010        jr Z,DW0low        RRCA        LD B,A        OR C        LD C,A        EXX         INC L        EXX         JP (IY)       ENDIF         DISPLAY "DWJP=",$      ;IF .$+(16*7+1)&256        align 256 ;DS .(-$)      ;ENDIFDWJP_=17       DUP 17        LD H,(IX+_) ;Y в текстуре        LD E,(HL) ;-Y*N        LD A,(DE)        XOR C ;xor!        LD (DE),A_=_-1       EDUP        IF optres       ;LD A,C ;%11000000       ;RRCA   ;%01100000       ;AND C  ;%01000000       ;JP Z,$+4       ;LD C,A       LD C,B       ENDIF         RRC C       IF lores        RRC C       ENDIF         JP NC,DW0        INC D       IF optres        LD A,D        CP scrbuf/256+scrwid       ELSE         DEC B       ENDIF         JP NZ,DW0        RET        endif ;~atm       if atmDWCLSALL        LD D,ceilingcolourbyte;%11111111        LD HL,#4000+36        CALL DWCLS        LD HL,#6000+36        CALL DWCLS        LD D,floorcolourbyte;%11110110        LD HL,#4000+(108*40)+36        CALL DWCLS        LD HL,#6000+(108*40)+36       ;CALL DWCLSDWCLS       LD A,(timer)       PUSH HL       PUSH AF        LD (dwclsp),SP        LD BC,40       ;LD D,B ;=0        LD E,D        LD A,scrhgt/2-8DWCL0   LD SP,HL        DUP 16;20        PUSH DE        EDUP         ADD HL,BC        DEC A        JP NZ,DWCL0dwclsp=$+1        LD SP,0       POP AF       LD HL,timer       CP (HL)       POP HL       RET Z;int detected - clear left        LD BC,-34        ADD HL,BC       LD A,D        LD DE,39        LD B,scrhgt/2-8DWCL1   LD (HL),D        INC HL        LD (HL),D        ADD HL,DE        DJNZ DWCL1       LD D,A ;keep D        RET DRAWWALLS;A=0..1 - номер битплана        LD (dwloopsp),SP        LD BC,40        LD IX,DWLOOP0        EXX         LD E,A ;0..1        LD H,tID/256        ;LD BC,#3FF7 ;(можно одно окно + кэш)        JP DWLOOPGODWLOOP0        LD SP,SPOIL6BSTACK;-2 ;можно портить        EXX         LD A,E        ADD A,2 ;чтобы не включать стр. экрана каждый столбец        CP scrwid*4        jr NC,DWLOOPQ        LD E,ADWLOOPGO        LD D,distbuf/256        LD A,(DE) ;ID       RRCA        ADD A,A ;флаг зеркальности в CY ;TODO рисовать уровни так, чтобы при взгляде вверх все были незеркальные, вниз - все зеркальные (тогда и зеркальность не нужно будет хранить?)       ;set 7,a ;быстрый пересчёт ID_DOOR (открытая дверь < 128)        INC D        LD L,A        LD A,(HL)      ;ld (pg8000),a      SETPG8000 ;OUT (C),A ;pg[ID]        INC L        LD A,(DE) ;texx=#40..#7F       jr NC,$+3       CPL ;зеркальная      AND 0x3F ;      or 0x80  ;TODO уже в ray?        LD HY,A        INC D        LD A,(HL) ;laddr[ID] = #02/#42/#82/#C2        LD LY,A        LD A,(DE) ;scale = 0..0x3f        EXX         LD E,(IY-2)        LD D,(IY-1) ;INT-PROOF       ADD A,A ;       ADD A,A ;при интерполяции нельзя обработать scale внутри таблицы tlogd2sca       ;NC        LD L,A        LD H,tscaljps/256        EXX         LD A,E        rra;SRL A        SRL A ;CY=0 для +0, CY=1 для +#2000        EXX         LD SP,IY        JP (HL)DWLOOPQdwloopsp=$+1        LD SP,0        RET        ENDIF ;atm;=====================       IF sprites       IF optressprDRAWSPRITEloresspr_hires        SLA E        RL D       LD B,H        LD C,L ;x        PUSH IX        POP HL        LD L,#FF ;texx LSB        ;LD LX,A ;scale        EXX          LD C,LX ;scale        EXX ;find left visible margin of sprite        INC C       INC CDRAWLl0 DEC C ;x       DEC C        jr Z,DRAWLl0Q       LD A,(BC)       CP LX       jr NC,DRAWLlQ        ADD HL,DE ;DE>0       LD A,#FF ;texxright        CP H        JP P,DRAWLl0        JR DRAWLlQDRAWLl0Q ;x=0       LD A,(BC)       CP LX       jr NC,DRAWLlQ        ADD HL,DE ;DE>0        DEC C ;x       DEC CDRAWLlQ ;H,C out of range;scan sprite to the right and keep H=texx in stack        INC C ;x in range       INC C        XOR A        SUB E        LD E,A        SBC A,D        SUB E        LD D,A        LD HX,1;B,1 ;sprite width counterDRAWRl0       LD A,(BC)       CP LX       jr NC,DRAWRlQ        ADD HL,DE ;DE<0       LD A,#7F ;texxleft-1        CP H ;texxleft        jr NC,DRAWRlQ       PUSH HL ;H in range        INC HX;B        INC C ;x       INC C        JP NZ,DRAWRl0DRAWRlQ ;H,C out of range        DEC HX;B       RET Z ;width=0, stack is empty        DEC C ;x in range       DEC C        LD A,C ;x        RRA         RRA         RRA         AND 31        ADD A,scrbuf/256        LD D,A        LD A,C        RRA         AND 3        INC A        LD B,A        LD A,#03        RRCA         RRCA         DJNZ $-2        LD C,A        CPL         LD B,A;D=scrbuf/256;B=running 0;C=running 1 ;D'=ID ;C'=scale        LD A,7 ;rlca        JP SDRAWPATCH ;SDRAW0       ENDIF DRAWSPRITE;don't spoil iy!;a=scale# = 0..0x3f;H=distbuf/256+2 ;ID,texx,dist;l=x;DE=texx step;HX=texxmid ;D'=ID (не atm)        LD LX,A ;scale      if atm        exx        ld a,d        add a,a        jr nc,$+4         ld a,16*2 ;костыль для go2        ;push af        add a,a        ld hl,tsprites;-4        add a,l        ld l,a        jr nc,$+3         inc h        ld a,(hl);        ld (drawspritepg),a;drawspritepg=$+1;       ld a,(ttexpgs+NTEXPGS)        ld b,ttexpgs/256        ld c,a        ld a,(bc)      SETPGC000        inc hl        ld a,(hl)       LD HX,a;#80+22;#C0 ;texx_center       ;ld hx,22/2        inc hl        ld a,(hl)        ld (drawspritetexxleft),a        inc hl        ld a,(hl)        ld (drawspritetexxright),a        exx        ;pop af      endif      if !atm       exx       ld a,d ;ID       add a,a       push af      if doublescr      and (spritesinpg*2-1)*2      else      and (spritesinpg-1)*2      endif       add a,0xc0+(texturesinpg*2);0xea       ld d,a               if doublescr        cp 0xc0+(texturesinpg*2)+(spritesinpg*2)        jr c,$+4        sub spritesinpg*2 ;NC        ld d,a        exx        ld a,0x10        jr c,$+4        ld a,0x10+pgtmp        call SETPG              endif        pop af        jr nc,DRAWSPRITE_nomirror         XOR A         SUB E         LD E,A         SBC A,D         SUB E         LD D,A ;6912 only!DRAWSPRITE_nomirror      endif	if FATMONSTERS        push hl        XOR A        SUB E        LD l,A        SBC A,D        SUB l        LD h,A        sra d        rr e        sra d        rr e        add hl,de        ex de,hl        pop hl        else         XOR A         SUB E         LD E,A         SBC A,D         SUB E         LD D,A	endif       IF optresspr        ld a,lx ;scale        CP lowmaxscale        JP NC,DRAWSPRITEloresspr_hires       ENDIF        LD B,H        LD C,L ;x         ld a,hx ;texxmid         ld h,a         LD L,0xFF ;texx LSB        if atm==0        EXX          LD C,LX ;scale        EXX         endif;find left visible margin of sprite;TODO fix пропущена колонка 0;TODO рисовать даже при центре за левым или правым краем экрана        INC C       IF loresspr_hires       INC C       ENDIF DRAWL0  DEC C ;x       IF loresspr_hires       DEC C       ENDIF         jr Z,DRAWL0Q       LD A,(BC)       CP LX       jr NC,DRAWLQ;        ADD HL,DE ;DE>0;         jr c,DRAWLQ;       ld a,h;drawspritetexxright=$+1;       cp 44/2 ;0xFF ;texxright;       JP C,DRAWL0        ADD HL,DE ;DE<0	 if atm         jr NC,DRAWLQtexx0       ld a,hdrawspritetexxleft=$+1       cp 0 ;texxleft        jr NC,DRAWL0	 else	ld a,0xff ;texxright ;TODO	cp h	jp p,DRAWL0	 endifDRAWLQtexx0        JR DRAWLQ;         or a;         sbc hl,de ;костыль;        JR DRAWLQDRAWL0Q ;x=0       LD A,(BC)       CP LX       jr NC,DRAWLQ        ADD HL,DE ;DE>0        DEC C ;x       IF loresspr_hires       DEC C       ENDIF DRAWLQ ;H,C out of range;scan sprite to the right and keep H=texx in stack        XOR A        SUB E        LD E,A        SBC A,D        SUB E        LD D,A                INC C ;x in range       IF loresspr_hires       INC C       ENDIF                 LD HX,1;B,1 ;sprite width counter	if atm       LD A,(BC)       CP LX       jr NC,DRAWRQ       add hl,de ;первое сложение не проверяем!       jp DRAWR0GO        endif        DRAWR0       LD A,(BC)       CP LX       jr NC,DRAWRQ;        ADD HL,DE ;DE<0;         jr NC,DRAWRQ;       ld a,h;drawspritetexxleft=$+1;       cp 0 ;texxleft;        jr C,DRAWRQ        ADD HL,DE ;DE>0	if atm         jr c,DRAWRQDRAWR0GO       ld a,hdrawspritetexxright=$+1       cp 44/2 ;0xFF ;texxright        else	ld a,0x7f ;texxleft-1	cp h	endif       JP NC,DRAWRQ       PUSH HL ;H in range        INC HX;B        INC C ;x       IF loresspr_hires       INC C       ENDIF        IF lores        JP P,DRAWR0       ELSE         JP NZ,DRAWR0       ENDIF DRAWRQ ;H,C out of range        DEC HX;B       RET Z ;width=0, stack is empty        DEC C ;x in range       IF loresspr_hires       DEC C       ENDIF               if atm;de=f(scale#,x);scr=f(x)        push bc;lx=scale# = 0..63        LD hl,tscales_rev        ld a,lx        add a,a        add a,l        ld l,a        jr nc,$+3        inc h        LD C,(HL)        INC HL        LD B,(HL) ;BC=scale        ld (drawsprscalebc),bc ;шаг по текстуре(+7.8) = 64/hgt = 1/scale        LD hl,tscales        ld a,lx        add a,a        add a,l        ld l,a        jr nc,$+3        inc h        LD C,(HL)        INC HL        LD B,(HL) ;BC=scale(+7.8) = 1/4(hgt=16) ... 4.0(hgt=256) ;hgt=64*scale;bc=scale        call scale2ytop;out: de=Y, lx=y        if 1==0        srl b        rr c        srl b        rr c        ld h,d        ld l,e        add hl,bc ;ylow        ld a,h        or a        ld a,l        jr nz,prsprtoolow        cp scrhgt        jr c,$+4prsprtoolow        ld a,scrhgt        endif               inc d        dec d        jr Z,drawsprnottoohigh        ld de,0drawsprnottoohigh        ;sub e        ;ld (drawsprscale),a ;реальное число выводимых строк (TODO сделать нормально с зумом)                ;LD A,D        ;OR A        ;jr NZ,drawsprTOP        ;LD A,E        ;CP Ytop        ;jr C,drawsprTOP        CALL YtoADDR;        JR drawsprnTOP;drawsprTOP;        LD DE,scrtop;drawsprnTOP        pop bc        LD A,C ;xright!        ;RRA         RRA         rra        jr nc,$+4         set 5,d        and 31        add a,e        ld e,a        jr nc,$+3         inc d        ld a,(getuser_scr_high_patch)        ld (SDRAW0_scrpgaddr),a        ld (SDRAW0_scrpgaddr2),a        ld (SDRAW0_scrpgaddr3),a        ld hl,(getuser_scr_low_patch)        xor l        ld (SDRAW0_scrpgaddrxor),a                ;call getuser_scr_low        ;ld (SDRAW0_scrpg),a ;TODO from x        ;ld (SDRAW0_low),a        ;ld h,a        ;call getuser_scr_high        ;xor h        ;ld (SDRAW0_high_xor_low),a       else        LD A,C ;x        RRA         RRA        IF lores == 0        RRA        ENDIF         AND 31        ADD A,scrbuf/256        LD D,A        LD A,C       IF loresspr_hires        RRA        ENDIF        IF loresspr        AND 3       ELSE         AND 7       ENDIF         INC A        LD B,A       IF loresspr == 0        LD A,#01       ELSE         LD A,#03       ENDIF DRAWRR0 RRCA        IF loresspr        RRCA        ENDIF         DJNZ DRAWRR0        LD C,A        CPL         LD B,A;D=scrbuf/256, B=running 0, C=running 1 (~atm)       endif ;~atm         ;D'=ID ;C'=scale#       IF optresspr ;~atm        XOR ASDRAWPATCH        LD (sdrawrlca),A       ENDIF        if atm==0SDRAW0;EOR-fill the column, then draw sprite column (pop hl from the stack, H=texx);D=scrbuf/256, B=running 0, C=running 1 (~atm)        LD H,D        LD L,scrbufflag&0xff       BIT 7,(HL)       JP NZ,SDRAWnX ;already filled        LD (HL),H ;>=128: eorcopy       EXX        LD A,C       EXX        CP lowmaxscale       jr NC,SDRAWXhigh        LD L,lowscrbuf&0xff        LD E,lowscrhgt/2-1        XOR ASDRAWXlow1 ;       DUP 16        XOR (HL)        LD (HL),A        INC L       EDUP         DEC E        JP P,SDRAWXlow1        LD A,+(scrhgt-lowscrhgt)/2SDRAWXlow2 ;       DUP 8        LD (HL),E ;-1        INC L       EDUP         DEC A        JP NZ,SDRAWXlow2        JP SDRAWnXSDRAWXhigh        LD L,scrbuf&0xff        LD E,scrhgt/2        XOR ASDRAWX ;       DUP 16        XOR (HL)        LD (HL),A        INC L       EDUP         DEC E        JP NZ,SDRAWXSDRAWnX ;SDRAW1 ;pixel column        EXX ;D=ID;C=scale#       POP HL         LD L,H ;texx       IF scale64       SRL L       ENDIF         LD H,D        LD A,(HL)        INC H        LD H,(HL)        LD L,A ;HL=spr;D'=scrbuf/256;B'=running 0;C'=running 1        JP SCALESPRITEGO       else ;~atm;рисуем справа налевоSDRAW0SDRAW0_scrpgaddr2=$+1        ld hl,user_scr0_high ;ok        ld a,l        jr SDRAW0goSDRAW0loop;de=screen;D'=ID;C'=scale#SDRAW0_scrpgaddr=$+1        ld hl,user_scr0_high ;ok        ld a,lSDRAW0_scrpgaddr3=$+1        cp 0        jr nz,SDRAW0go        bit 5,d        res 5,d        jr nz,SDRAW0go        set 5,d        dec deSDRAW0goSDRAW0_scrpgaddrxor=$+1        xor 0        ld (SDRAW0_scrpgaddr),a        ld a,(hl)       POP HL        SETPG4000;4000: screen;c000: texture (уже поставлено в начале DRAWSPRITE);8000: scaler (TODO)       ld a,h ;texx=#00..#FF        push de        exx        pop hl        push hl        ld bc,40        ld e,IMPOSSIBLECOLOR        exx        ld hl,0xc000        ld e,adrawsprscalebc=$+1        ld bc,0        drawspr00        ld d,h        ld a,(de)        exx        cp e;IMPOSSIBLECOLOR        jr z,$+3         ld (hl),a        add hl,bc        exx        add hl,bc        jp nc,drawspr00 ;/m                pop de        DEC HX;B ;todo E'?        JP nz,SDRAW0loop        ret       endif ;atm        if atm == 0;вывод спрайтов: y,yEND1,yEND0;y=yEND1: пропуск рисования единиц ;0 может также получиться на верх/ниж кромке в большом масштабе;y=#C0, yEND1=#FF: конец текстуры - два специальных Y, ;которым в таблице соответствуют константы при любом масштабе  ;можно одну, рассчитанную из какого-то масштаба?;yEND0=yEND1: пропуск рисования нулей ;0 может также получиться на верх/ниж кромке в большом масштабеmaxlinehgt=59        align 256 ;DS .(-$);круглый адрес: пропуск рисовалки нулей        JP EXXSCALESPRITE1        DS 0xff&(-(4*maxlinehgt)-$)SCALESPRITE0DRAW;рисовалка нулей (AND B)       DUP maxlinehgt ;MAX=62(59 с SCALESPRITELOOP)                      ;большие залитые области рубить на части        LD A,(DE)        AND B        LD (DE),A        DEC E       EDUP EXXSCALESPRITE1;круглый адрес        DISPLAY $,"=#XX00"        EXX         INC LSCALESPRITEGO;HL=spr;D=ID;C=scale;D'=scrbuf/256;(HL'=tempjp);B'=running 0;C'=running 1        LD B,(HL) ;Y в текстуре или #C0(читает 0)        INC L        LD A,(BC) ;Y*N (0 в конце текстуры)        EXX         LD E,A;SCALESPRITE1GO        EXX         LD B,(HL) ;Y2 в текстуре (<=Y) или #FF(читает 1)        INC L        LD A,(BC) ;Y2*N (1 в конце текстуры)        EXX         SUB E        ADD A,A        ADD A,A        LD L,A ;(=4 в конце текстуры)        LD H,SCALESPRITE1DRAW/256        JP (HL) ;рисуем единицы или выходим        align 256 ;DS .(-$);круглый адрес: пропуск рисовалки единиц        JP EXXSCALESPRITE0        NOP ;спецадрес 4: конец текстуры;как сюда попасть: #C0(читает 0),#FF(читает 1)SDRAW0SKIPQ        DEC HX;B ;todo E'?        RET Z        LD A,C        RLCA        IF loresspr|optressprsdrawrlca=$        RLCA        ENDIF         LD C,A        CPL         LD B,A        JP NC,SDRAW1        DEC D        JP SDRAW0       DISPLAY $        DS 0xff&(-(4*maxlinehgt)-$)       DISPLAY "=",$SCALESPRITE1DRAW;рисовалка единиц (OR C)       DUP maxlinehgt ;MAX=63                      ;большие залитые области рубить на части        LD A,(DE)        OR C        LD (DE),A        DEC E       EDUP        ;ORG $-1EXXSCALESPRITE0        EXX ;круглый адрес        LD B,(HL) ;Y3 в текстуре (<=Y2)        LD A,(BC) ;Y3*N        EXX         SUB E        ADD A,A        ADD A,A        LD L,A        LD H,SCALESPRITE0DRAW/256        JP (HL) ;рисуем нули       IF 0testsprite        DB #F0,#EF,#E7        DB #D2,#D0,#C4        DB #C0,#FF       ENDIF        endif ;~atm       ENDIF ;sprites