Библиотека stdio предназначена для сопряжения программ, работающих в текстовом режиме, с интерфейсом терминала и перенаправляемой передачи данных по пайпам (очередям).

Программы под NedoOS бывают в основном двух типов: текстовые (которые должны запускаться из cmd и nv в текущем терминале) и графические (которые должны сами включать свой графический режим, а предварительно вызвать OS_HIDEFROMPARENT, чтобы cmd или nv перестал ожидать завершения).

Текстовые программы должны иметь входной пайп (stdin) и выходной пайп (stdout). В ядре поддержан также выходной пайп stderr, но он пока не поддержан в библиотеке и в cmd.

Переделка типичной текстовой программы:
1. инклюдить stdio.asm
2. в начале программы убрать SETGFX и поставить call initstdio
3. все PRCHAR заменить на PRCHAR_
4. все GET_KEY заменить на GETKEY_
5. все OS_SETXY заменить на SETXY_
6. все YIELDGETKEYLOOP заменить на call yieldgetkeyloop
7. все OS_SETCOLOR заменить на SETCOLOR_, но цвета давать не в E, а в DE (paper0..7, ink0..15)
8. все OS_SCROLLUP заменить на call scrollup, все OS_SCROLLDOWN заменить на call scrolldown

Для большинства программ этого дожно хватить. Проблемы могут быть:
- со скроллом окна (процедуры scrollup, scrolldown имеют интерфейс такой же, как OS_SCROLLUP, OS_SCROLLDOWN, но не работают в удалённых терминалах)
- с печатью курсора атрибутами. Курсор ввода текста печатать не надо, его печатает терминал. Надо только сделать SETXY_ в нужном месте перед ожиданием клавиш. Большой курсор можно печатать так: ld de,paperink:SETCOLOR_:call setcolor_invisible:печатаем пробелы:call setcolor_visible (это тоже не работает в удалённых терминалах, поэтому лучше всё-таки перепечатывать текст под курсором цветом курсора).
- с тормозами. Вывод текста надо делать не по одной букве, а сразу слать целый блок, например:

prtext
;hl=text
        push hl
        call strlen ;hl=length
        pop de ;de=text
        jp sendchars

strlen
;hl=str
;out: hl=length
        xor a
        ld b,a
        ld c,a ;чтобы точно найти терминатор
        cpir ;найдём обязательно, если длина=0, то bc=-1 и т.д.
        ld hl,-1
        or a
        sbc hl,bc
        ret

- с миганием курсора при движении мышки. Это происходит потому, что события мышки тоже присылаются по call yieldgetkeyloop. Если вам вернули A=0, то не надо идти на перепечатку курсора, а надо or a:jr z,передyieldgetkeyloop. Процедура GETKEY_ пока не умеет мышку, потом будет.
- пока что A=C, то есть буквы без языка не присылаются. Язык всегда есть в коде.
